<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gas Pipeline Monitoring Dashboard with Post Processing</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700&display=swap" rel="stylesheet" />
  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Chart.js Annotation Plugin (loaded for threshold lines etc.) -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0"></script>
  <style>
    /* ========= Global Reset & Base ========= */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Roboto', sans-serif;
      overflow: hidden;
      background: linear-gradient(45deg, #1a2a6c, #b21f1f, #fdbb2d);
      background-size: 600% 600%;
      animation: gradientAnimation 20s ease infinite;
      position: relative;
      color: #fff;
    }
    @keyframes gradientAnimation {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    /* ========= Particle Canvas ========= */
    #particleCanvas {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
    }
    /* ========= Sidebar ========= */
    .sidebar {
      position: fixed; top: 0; left: 0; bottom: 0; width: 250px;
      background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(10px);
      padding: 20px; z-index: 1;
    }
    .sidebar h2 { text-align: center; margin-bottom: 20px; font-size: 24px; }
    .nav-menu { list-style: none; padding-left: 0; margin-bottom: 15px; }
    .nav-menu li {
      margin: 10px 0; padding: 8px 12px; background: rgba(255, 255, 255, 0.1);
      border-radius: 5px; cursor: pointer; transition: background 0.3s; font-size: 16px;
    }
    .nav-menu li:hover, .nav-menu li.active { background: rgba(255, 255, 255, 0.3); }
    /* Sidebar Content */
    #sidebarContent > div { display: none; }
    #sectorsTab { display: block; }
    .sector-list { list-style: none; padding-left: 0; margin-top: 10px; }
    .sector-list li {
      padding: 8px 10px; margin: 5px 0; background: rgba(255, 255, 255, 0.1);
      border-radius: 5px; cursor: pointer; transition: background 0.3s; font-size: 14px;
    }
    .sector-list li:hover, .sector-list li.active { background: rgba(255, 255, 255, 0.2); }
    #sectorsTab > .header { display: flex; justify-content: space-between; align-items: center; padding: 0 10px; }
    #sectorsTab h3 { margin: 0; font-size: 16px; }
    #addSectorBtn { font-size: 16px; padding: 2px 6px; cursor: pointer; }
    /* Devices Tab */
    #devicesTab .device-list { list-style: none; padding-left: 0; margin-top: 10px; }
    #devicesTab .device-list li {
      padding: 8px 10px; margin: 5px 0; background: rgba(255, 255, 255, 0.1);
      border-radius: 5px; cursor: pointer; transition: background 0.3s; font-size: 14px;
    }
    #devicesTab .device-list li:hover, #devicesTab .device-list li.active { background: rgba(255, 255, 255, 0.2); }
    /* Post Processing Tab */
    #postProcessingTab { padding: 10px; }
    /* Warnings Tab */
    #warningsTab { padding: 10px; }
    #warningsTab h3 { font-size: 18px; margin-bottom: 8px; }
    #warningsTab p { margin-bottom: 5px; }
    /* Historical Data Tab (Sidebar) */
    #historicalDataTab { padding: 10px; display: none; }
    /* ========= Main Content ========= */
    .main-content {
      margin-left: 270px; padding: 20px; height: 100vh; overflow-y: auto; z-index: 1;
    }
    header {
      display: flex; justify-content: space-between; align-items: center;
      background: rgba(0, 0, 0, 0.5); padding: 10px 20px; border-radius: 10px;
      margin-bottom: 20px; backdrop-filter: blur(5px);
    }
    header .search-box input {
      padding: 8px 15px; border: none; border-radius: 20px; outline: none; width: 200px;
    }
    header .user-profile {
      width: 40px; height: 40px; border-radius: 50%; background: #4CAF50;
      display: flex; justify-content: center; align-items: center; font-weight: bold; cursor: pointer;
    }
    /* Views */
    #dashboardView, #warningsView, #postProcessingView, #historicalDataView { display: none; }
    #dashboardView { display: block; }
    .dashboard-cards {
      display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px; margin-bottom: 30px;
    }
    .card {
      background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(5px); border-radius: 10px;
      padding: 20px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      transition: transform 0.3s, box-shadow 0.3s; opacity: 0; animation: fadeInUp 0.5s forwards;
    }
    .card:hover { transform: translateY(-5px); box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4); }
    .card:nth-child(1) { animation-delay: 0.2s; }
    .card:nth-child(2) { animation-delay: 0.3s; }
    .card:nth-child(3) { animation-delay: 0.4s; }
    .card:nth-child(4) { animation-delay: 0.5s; }
    @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    /* Charts Section */
    .charts {
      display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
    }
    .chart-card {
      background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(5px); border-radius: 10px;
      padding: 20px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); animation: fadeInUp 0.5s forwards;
    }
    .chart-card h3 { margin-bottom: 15px; }
    /* Enlarged Weekly Forecast Card */
    #weeklyForecastCard {
      grid-column: span 2;
      padding: 30px;
      min-height: 450px;
    }
    #weeklyForecastChart {
      width: 100% !important;
      height: 400px !important;
    }
    /* Bolt Health Forecast Card (New) */
    #boltHealthCard {
      grid-column: span 2;
      padding: 30px;
      min-height: 450px;
    }
    #boltHealthChart {
      width: 100% !important;
      height: 400px !important;
    }
    /* Post Processing View */
    #postProcessingView header { margin-bottom: 10px; }
    #postProcessingSector { font-size: 18px; margin-bottom: 10px; text-align: center; }
    /* Warnings View */
    #warningsView h2 { margin-bottom: 20px; }
    .warning-card {
      background: rgba(0, 0, 0, 0.5); border-left: 5px solid; border-radius: 8px;
      margin-bottom: 15px; padding: 10px 15px; transition: background 0.3s, transform 0.3s; position: relative;
    }
    #tempWarningCard { border-color: red; }
    #humWarningCard { border-color: orange; }
    .warning-card:hover { background: rgba(0, 0, 0, 0.6); transform: scale(1.02); }
    .warning-header { display: flex; align-items: center; justify-content: space-between; cursor: pointer; }
    .warning-header h3 { margin: 0; font-size: 18px; flex-grow: 1; padding-left: 10px; }
    .warning-icon { font-size: 22px; }
    .warning-details {
      padding-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.3);
      margin-top: 8px; font-size: 14px; color: #f1f1f1;
    }
    .toggle-details, .acknowledge-warning, .resend-telegram {
      background: transparent; border: 1px solid #fff; border-radius: 4px;
      color: #fff; font-size: 14px; cursor: pointer; padding: 3px 6px; margin-left: 5px; outline: none;
    }
    .notification-status { font-size: 12px; margin-top: 5px; color: #ccc; }
    /* Warning Log */
    #warningLog { margin-top: 20px; }
    #warningLog h3 { margin-bottom: 10px; }
    .warning-log-container {
      max-height: 250px; overflow-y: auto; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px;
    }
    .warning-log-container table {
      width: 100%; border-collapse: collapse; font-size: 13px; color: #fff;
    }
    .warning-log-container th, .warning-log-container td {
      padding: 6px; border: 1px solid rgba(255,255,255,0.2); text-align: center;
    }
    .acknowledged-row { background: rgba(0, 128, 0, 0.3); text-decoration: line-through; }
    .critical-row { background: rgba(255, 0, 0, 0.3); }
    /* Responsive */
    @media (max-width: 768px) {
      .main-content { margin-left: 0; }
      .charts { grid-template-columns: 1fr; }
      #weeklyForecastCard, #boltHealthCard { grid-column: span 1; }
    }
  </style>
</head>
<body>
  <!-- Particle Background Canvas -->
  <canvas id="particleCanvas"></canvas>
  <!-- Sidebar Navigation -->
  <div class="sidebar">
    <h2>IoT Dashboard</h2>
    <ul class="nav-menu">
      <li data-tab="sectors" class="active">Sectors</li>
      <li data-tab="devices">Devices</li>
      <li data-tab="postProcessing">Post Processing</li>
      <li data-tab="warnings">Warnings</li>
      <li data-tab="historicalData">Historical Data</li>
    </ul>
    <div id="sidebarContent">
      <!-- Sectors Tab -->
      <div id="sectorsTab">
        <div class="header">
          <h3>Sectors</h3>
          <button id="addSectorBtn">+</button>
        </div>
        <ul class="sector-list" id="sectorsList"><!-- Dynamically populated --></ul>
      </div>
      <!-- Devices Tab -->
      <div id="devicesTab">
        <ul class="device-list" id="boltsList"><!-- Dynamically populated --></ul>
      </div>
      <!-- Post Processing Tab -->
      <div id="postProcessingTab">
        <p style="padding:10px;">Analytics for the selected sector are shown in the main area below.</p>
      </div>
      <!-- Warnings Tab -->
      <div id="warningsTab">
        <div>
          <h3>Warning Summary</h3>
          <p><span style="color:red; font-weight:bold;">Temperature:</span> <span id="sidebarTempWarnings">0</span> occurrences</p>
          <p><span style="color:orange; font-weight:bold;">Humidity:</span> <span id="sidebarHumWarnings">0</span> occurrences</p>
        </div>
      </div>
      <!-- Historical Data Tab (Sidebar) -->
      <div id="historicalDataTab">
        <p style="padding:10px;">View full historical sensor data here.</p>
      </div>
    </div>
  </div>
  <!-- Main Content Area -->
  <div class="main-content">
    <!-- Dashboard View -->
    <div id="dashboardView">
      <header>
        <div class="search-box"><input type="text" placeholder="Search sectors..." /></div>
        <div class="user-profile">A</div>
      </header>
      <section class="dashboard-cards" id="dashboardCards">
        <div class="card" id="sectorCard">
          <h3 id="sectorName">Pipeline Sector: N/A</h3>
          <p>Sensor Bolts Installed: <strong id="boltsCount">--</strong></p>
          <p>Status: <strong id="sensorStatus" style="color: #4CAF50;">Online</strong></p>
          <p>Temperature: <strong id="temperatureValue">--</strong> °C</p>
          <p>Humidity: <strong id="humidityValue">--</strong> %</p>
        </div>
      </section>
      <section class="charts">
        <div class="chart-card">
          <h3>Temperature Over Time</h3>
          <canvas id="temperatureChart"></canvas>
        </div>
        <div class="chart-card">
          <h3>Humidity Over Time</h3>
          <canvas id="humidityChart"></canvas>
        </div>
      </section>
    </div>
    <!-- Warnings View -->
    <div id="warningsView">
      <header>
        <div class="search-box"><input type="text" placeholder="Search warnings..." /></div>
        <div class="user-profile">A</div>
      </header>
      <h2>Warnings</h2>
      <div class="warning-card" id="tempWarningCard">
        <div class="warning-header">
          <span class="warning-icon">⚠️</span>
          <h3>Temperature Threshold Exceeded</h3>
          <button class="toggle-details">Details</button>
        </div>
        <div class="warning-details" style="display:none;">
          <p>Exceeded <span id="tempWarningCount">0</span> time(s).</p>
          <p class="notification-status" id="tempNotificationStatus">Telegram: Not Sent</p>
          <div style="margin-top:5px;">
            <button class="acknowledge-warning" data-type="Temperature">Acknowledge</button>
            <button class="resend-telegram" data-type="Temperature">Resend Telegram</button>
          </div>
        </div>
      </div>
      <div class="warning-card" id="humWarningCard">
        <div class="warning-header">
          <span class="warning-icon">⚠️</span>
          <h3>Humidity Threshold Exceeded</h3>
          <button class="toggle-details">Details</button>
        </div>
        <div class="warning-details" style="display:none;">
          <p>Exceeded <span id="humWarningCount">0</span> time(s).</p>
          <p class="notification-status" id="humNotificationStatus">Telegram: Not Sent</p>
          <div style="margin-top:5px;">
            <button class="acknowledge-warning" data-type="Humidity">Acknowledge</button>
            <button class="resend-telegram" data-type="Humidity">Resend Telegram</button>
          </div>
        </div>
      </div>
      <div id="warningLog">
        <h3>Warning Log</h3>
        <div class="warning-log-container">
          <table>
            <thead>
              <tr>
                <th>Time</th>
                <th>Type</th>
                <th>Value</th>
                <th>Severity</th>
                <th>Status</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="warningLogBody"><!-- Dynamically populated --></tbody>
          </table>
        </div>
      </div>
    </div>
    <!-- Post Processing View -->
    <div id="postProcessingView" style="display:none">
      <header>
        <div class="search-box"><input type="text" placeholder="Search analytics..." /></div>
        <div class="user-profile">A</div>
      </header>
      <h3 id="postProcessingSector" style="text-align:center; margin-bottom:10px;">Post Processing for: N/A</h3>
      <section class="dashboard-cards" id="postProcessingCards">
        <div class="card" id="anomalyCard">
          <h3>Anomaly Detection</h3>
          <div id="anomalyContent"><!-- Anomaly info --></div>
        </div>
        <div class="card" id="trendCard">
          <h3>Trend Analysis</h3>
          <div id="trendContent"><!-- Trend info --></div>
        </div>
        <div class="card" id="severityCard">
          <h3>Severity Alerts</h3>
          <div id="severityContent"><!-- Severity info --></div>
        </div>
        <div class="card" id="energyCard">
          <h3>Energy Efficiency Recommendations</h3>
          <div id="energyContent"><!-- Recommendation info --></div>
        </div>
        <div class="card" id="correlationCard">
          <h3>Correlation Analysis</h3>
          <div id="correlationContent"><!-- Correlation info --></div>
        </div>
        <div class="card" id="energyGaugeCard">
          <h3>Energy Efficiency Score</h3>
          <canvas id="energyGaugeChart"></canvas>
        </div>
        <!-- Enlarged Weekly Forecast Card -->
        <div class="card" id="weeklyForecastCard">
          <h3>Weekly Forecast</h3>
          <canvas id="weeklyForecastChart"></canvas>
        </div>
        <!-- New Bolt Health Forecast Card -->
        <div class="card" id="boltHealthCard">
          <h3>Bolt Health Forecast</h3>
          <canvas id="boltHealthChart"></canvas>
        </div>
      </section>
    </div>
    <!-- Historical Data View -->
    <div id="historicalDataView" style="display:none;">
      <header>
        <div class="search-box"><input type="text" placeholder="Search historical data..." /></div>
        <div class="user-profile">A</div>
      </header>
      <h2>Historical Data</h2>
      <!-- Filter and Download Controls -->
      <div id="historicalControls" style="margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
        <label for="filterSelect" style="font-size: 16px;">Filter:</label>
        <select id="filterSelect" style="padding: 5px 10px; border-radius: 4px; border: none;">
          <option value="all">All</option>
          <option value="hourly">Hourly</option>
          <option value="daily">Daily</option>
          <option value="weekly">Weekly</option>
          <option value="monthly">Monthly</option>
        </select>
        <button id="downloadDataBtn" style="padding: 5px 10px; border-radius: 4px; border: none; background-color: #4caf50; color: #fff; cursor: pointer;">Download Data</button>
      </div>
      <div class="chart-card">
        <h3>Historical Temperature & Humidity</h3>
        <canvas id="historicalDataChart"></canvas>
      </div>
    </div>
  </div>
  <script>
    /***********************
     * STATE PERSISTENCE FUNCTIONS
     ***********************/
    function loadState() {
      const stateStr = localStorage.getItem('dashboardState');
      if (stateStr) {
        try {
          const state = JSON.parse(stateStr);
          if (state.sectors) { sectors = state.sectors; }
          if (state.currentSectorId) { currentSector = sectors.find(sec => sec.id === state.currentSectorId) || sectors[0]; }
          simulationTime = state.simulationTime || 0;
          tempWarningCount = state.tempWarningCount || 0;
          humWarningCount = state.humWarningCount || 0;
          warningLogs = state.warningLogs || [];
          sectorCache = state.sectorCache || {};
          sectors.forEach(sec => { 
            if (!sectorCache[sec.id]) { 
              sectorCache[sec.id] = { labels: [], timestamps: [], temperatures: [], humidities: [] }; 
            } else if (!sectorCache[sec.id].timestamps) {
              sectorCache[sec.id].timestamps = [];
            }
            if (!sec.boltsHealth) {
              sec.boltsHealth = Array(sec.bolts).fill(100);
              sec.avgDegradationRate = 0;
            }
          });
          console.log("State loaded from localStorage.");
        } catch (err) { console.error("Error loading state:", err); }
      }
    }
    function saveState() {
      const state = { sectors, currentSectorId: currentSector.id, simulationTime, tempWarningCount, humWarningCount, warningLogs, sectorCache };
      localStorage.setItem('dashboardState', JSON.stringify(state));
    }
    /***********************
     * GLOBAL VARIABLES & SECTOR SETUP
     ***********************/
    let sectors = [ { id: 'sector1', name: 'Sector 1', bolts: 3, baseTemp: 25, baseHumidity: 55, boltsHealth: Array(3).fill(100), avgDegradationRate: 0 } ];
    let currentSector = sectors[0];
    let simulationTime = 0;
    let thresholdTemp = 28; // °C
    let thresholdHumidity = 65; // %
    let tempWarningCount = 0, humWarningCount = 0;
    let prevTempAbove = false, prevHumAbove = false;
    let warningLogs = [];
    const maxPoints = 20;
    let sectorCache = {};
    sectors.forEach(sec => {
      if (!sectorCache[sec.id]) {
        sectorCache[sec.id] = { labels: [], timestamps: [], temperatures: [], humidities: [] };
      } else if (!sectorCache[sec.id].timestamps) {
        sectorCache[sec.id].timestamps = [];
      }
    });
    loadState();
    /***********************
     * PARTICLE ANIMATION
     ***********************/
    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d');
    let particles = [];
    const particleCount = 100;
    function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resizeCanvas); resizeCanvas();
    function initParticles() {
      particles = [];
      for (let i = 0; i < particleCount; i++) {
        particles.push({ x: Math.random()*canvas.width, y: Math.random()*canvas.height,
          vx: (Math.random()-0.5)*0.5, vy: (Math.random()-0.5)*0.5,
          radius: Math.random()*2+1, opacity: Math.random()*0.5+0.3 });
      }
    }
    initParticles();
    function animateParticles() {
      ctx.clearRect(0,0,canvas.width, canvas.height);
      particles.forEach(p => {
        p.x += p.vx; p.y += p.vy;
        if (p.x<0 || p.x>canvas.width) p.vx = -p.vx;
        if (p.y<0 || p.y>canvas.height) p.vy = -p.vy;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
        ctx.fillStyle = `rgba(255,255,255,${p.opacity})`;
        ctx.fill();
      });
      requestAnimationFrame(animateParticles);
    }
    animateParticles();
    /***********************
     * CHART SETUP: IMPROVED VISUALIZATION WITH SHORT-TERM PREDICTION DATASETS
     ***********************/
    const tempCtx = document.getElementById('temperatureChart').getContext('2d');
    const tempGradient = tempCtx.createLinearGradient(0,0,0,400);
    tempGradient.addColorStop(0, 'rgba(255, 99, 132, 0.5)');
    tempGradient.addColorStop(1, 'rgba(255, 159, 64, 0.1)');
    const humidityCtx = document.getElementById('humidityChart').getContext('2d');
    const humGradient = humidityCtx.createLinearGradient(0,0,0,400);
    humGradient.addColorStop(0, 'rgba(54, 162, 235, 0.5)');
    humGradient.addColorStop(1, 'rgba(75, 192, 192, 0.1)');
    const temperatureChart = new Chart(tempCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'Temperature (°C)',
            data: [],
            backgroundColor: tempGradient,
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 2,
            tension: 0.4,
            fill: true,
            pointRadius: 4,
            pointHoverRadius: 6,
            pointBackgroundColor: 'rgba(255, 99, 132, 1)'
          },
          {
            label: 'Short-term Prediction',
            data: [],
            borderColor: 'rgba(255, 99, 132, 0.7)',
            borderDash: [6, 6],
            borderWidth: 2,
            tension: 0.4,
            fill: false,
            pointRadius: 0,
            pointHoverRadius: 0
          }
        ]
      },
      options: {
        responsive: true,
        animation: { duration: 500 },
        plugins: {
          tooltip: { mode: 'index', intersect: false },
          annotation: {
            annotations: {
              thresholdLine: {
                type: 'line',
                yMin: thresholdTemp,
                yMax: thresholdTemp,
                borderColor: 'red',
                borderWidth: 2,
                label: { enabled: true, content: 'Temp Threshold', backgroundColor: 'rgba(255,0,0,0.7)' }
              }
            }
          },
          legend: { labels: { color: '#fff' } }
        },
        scales: {
          x: { display: true, title: { display: true, text: 'Time', color: '#fff' },
               grid: { color: 'rgba(255,255,255,0.2)' }, ticks: { color: '#fff' } },
          y: { display: true, title: { display: true, text: 'Temperature (°C)', color: '#fff' },
               grid: { color: 'rgba(255,255,255,0.2)' }, ticks: { color: '#fff' } }
        }
      }
    });
    const humidityChart = new Chart(humidityCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'Humidity (%)',
            data: [],
            backgroundColor: humGradient,
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 2,
            tension: 0.4,
            fill: true,
            pointRadius: 4,
            pointHoverRadius: 6,
            pointBackgroundColor: 'rgba(54, 162, 235, 1)'
          },
          {
            label: 'Short-term Prediction',
            data: [],
            borderColor: 'rgba(54, 162, 235, 0.7)',
            borderDash: [6, 6],
            borderWidth: 2,
            tension: 0.4,
            fill: false,
            pointRadius: 0,
            pointHoverRadius: 0
          }
        ]
      },
      options: {
        responsive: true,
        animation: { duration: 500 },
        plugins: {
          tooltip: { mode: 'index', intersect: false },
          annotation: {
            annotations: {
              thresholdLine: {
                type: 'line',
                yMin: thresholdHumidity,
                yMax: thresholdHumidity,
                borderColor: 'orange',
                borderWidth: 2,
                label: { enabled: true, content: 'Humidity Threshold', backgroundColor: 'rgba(255,165,0,0.7)' }
              }
            }
          },
          legend: { labels: { color: '#fff' } }
        },
        scales: {
          x: { display: true, title: { display: true, text: 'Time', color: '#fff' },
               grid: { color: 'rgba(255,255,255,0.2)' }, ticks: { color: '#fff' } },
          y: { display: true, title: { display: true, text: 'Humidity (%)', color: '#fff' },
               grid: { color: 'rgba(255,255,255,0.2)' }, ticks: { color: '#fff' } }
        }
      }
    });
    /***********************
     * ENERGY EFFICIENCY GAUGE (POST PROCESSING)
     ***********************/
    const energyGaugeCtx = document.getElementById('energyGaugeChart').getContext('2d');
    let energyGaugeChart = new Chart(energyGaugeCtx, {
      type: 'doughnut',
      data: { datasets: [{ data: [100, 0], backgroundColor: ['#4caf50', '#ddd'], borderWidth: 0 }] },
      options: {
        rotation: -90 * Math.PI / 180,
        circumference: 180 * Math.PI / 180,
        cutout: '70%',
        plugins: { tooltip: { enabled: false }, legend: { display: false },
          title: { display: true, text: 'Score', position: 'bottom', color: '#fff', font: { size: 16 } }
        }
      }
    });
    /***********************
     * WEEKLY FORECAST CHART (POST PROCESSING)
     ***********************/
    const weeklyForecastCtx = document.getElementById('weeklyForecastChart').getContext('2d');
    let weeklyForecastChart = new Chart(weeklyForecastCtx, {
      type: 'line',
      data: {
        labels: ['Day 1','Day 2','Day 3','Day 4','Day 5','Day 6','Day 7'],
        datasets: [
          {
            label: 'Temperature Forecast (°C)',
            data: [],
            borderColor: 'rgba(255, 99, 132, 1)',
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            borderWidth: 2,
            tension: 0.4,
            fill: true
          },
          {
            label: 'Humidity Forecast (%)',
            data: [],
            borderColor: 'rgba(54, 162, 235, 1)',
            backgroundColor: 'rgba(54, 162, 235, 0.2)',
            borderWidth: 2,
            tension: 0.4,
            fill: true
          }
        ]
      },
      options: {
        responsive: true,
        plugins: { legend: { labels: { color: '#fff' } } },
        scales: {
          x: { title: { display: true, text: 'Day', color: '#fff' },
               grid: { color: 'rgba(255,255,255,0.2)' }, ticks: { color: '#fff' } },
          y: { title: { display: true, text: 'Value', color: '#fff' },
               grid: { color: 'rgba(255,255,255,0.2)' }, ticks: { color: '#fff' } }
        }
      }
    });
    /***********************
     * BOLT HEALTH FORECAST CHART (POST PROCESSING)
     ***********************/
    const boltHealthCtx = document.getElementById('boltHealthChart').getContext('2d');
    let boltHealthChart = new Chart(boltHealthCtx, {
      type: 'bar',
      data: {
        labels: [],
        datasets: [
          {
            label: 'Current Health (%)',
            data: [],
            backgroundColor: 'rgba(75, 192, 192, 0.6)'
          },
          {
            label: 'Predicted Health (1 Week)',
            data: [],
            backgroundColor: 'rgba(255, 159, 64, 0.6)'
          }
        ]
      },
      options: {
        responsive: true,
        scales: {
          x: { title: { display: true, text: 'Bolt', color: '#fff' },
               ticks: { color: '#fff' },
               grid: { display: false } },
          y: { beginAtZero: true, max: 100, title: { display: true, text: 'Health (%)', color: '#fff' },
               ticks: { color: '#fff' },
               grid: { color: 'rgba(255,255,255,0.2)' } }
        },
        plugins: { legend: { labels: { color: '#fff' } } }
      }
    });
    /***********************
     * HISTORICAL DATA CHART SETUP
     ***********************/
    const historicalCtx = document.getElementById('historicalDataChart').getContext('2d');
    const historicalChart = new Chart(historicalCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'Temperature (°C)',
            data: [],
            borderColor: 'rgba(255, 99, 132, 1)',
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 2
          },
          {
            label: 'Humidity (%)',
            data: [],
            borderColor: 'rgba(54, 162, 235, 1)',
            backgroundColor: 'rgba(54, 162, 235, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 2
          }
        ]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { labels: { color: '#fff', font: { size: 14 } } },
          tooltip: { mode: 'index', intersect: false }
        },
        scales: {
          x: {
            type: 'category',
            title: { display: true, text: 'Time', color: '#fff', font: { size: 16 } },
            grid: { color: 'rgba(255,255,255,0.1)' },
            ticks: { color: '#fff', autoSkip: true, maxTicksLimit: 20 }
          },
          y: {
            title: { display: true, text: 'Value', color: '#fff', font: { size: 16 } },
            grid: { color: 'rgba(255,255,255,0.1)' },
            ticks: { color: '#fff' }
          }
        },
        elements: { line: { tension: 0.4 } }
      }
    });
    /***********************
     * FILTERING & DOWNLOAD FUNCTIONS FOR HISTORICAL DATA
     ***********************/
    function getFilteredHistoricalData(filter) {
      const cache = sectorCache[currentSector.id];
      let indices = [];
      const now = Date.now();
      let threshold;
      switch(filter) {
        case 'hourly': threshold = 3600 * 1000; break;
        case 'daily': threshold = 24 * 3600 * 1000; break;
        case 'weekly': threshold = 7 * 24 * 3600 * 1000; break;
        case 'monthly': threshold = 30 * 24 * 3600 * 1000; break;
        default: threshold = 0;
      }
      if (threshold > 0) {
        for (let i = 0; i < cache.timestamps.length; i++) {
          if (now - cache.timestamps[i] <= threshold) {
            indices.push(i);
          }
        }
      } else {
        for (let i = 0; i < cache.timestamps.length; i++) { indices.push(i); }
      }
      return {
        labels: indices.map(i => cache.labels[i]),
        temperatures: indices.map(i => cache.temperatures[i]),
        humidities: indices.map(i => cache.humidities[i]),
        timestamps: indices.map(i => cache.timestamps[i])
      };
    }
    function updateHistoricalChart() {
      const filter = document.getElementById('filterSelect').value;
      const data = getFilteredHistoricalData(filter);
      historicalChart.data.labels = data.labels;
      historicalChart.data.datasets[0].data = data.temperatures;
      historicalChart.data.datasets[1].data = data.humidities;
      historicalChart.update();
    }
    document.getElementById('downloadDataBtn').addEventListener('click', function() {
      const filter = document.getElementById('filterSelect').value;
      const data = getFilteredHistoricalData(filter);
      let csvContent = "data:text/csv;charset=utf-8,Timestamp,Time,Temperature,Humidity\n";
      for (let i = 0; i < data.timestamps.length; i++) {
        const ts = data.timestamps[i];
        const timeString = data.labels[i];
        const temp = data.temperatures[i];
        const hum = data.humidities[i];
        const dateStr = new Date(ts).toLocaleString();
        csvContent += `${dateStr},${timeString},${temp},${hum}\n`;
      }
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", "historical_data.csv");
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });
    document.getElementById('filterSelect').addEventListener('change', updateHistoricalChart);
    setInterval(updateHistoricalChart, 5000);
    /***********************
     * PREDICTION HELPER FUNCTIONS
     ***********************/
    function computePredictions(arr, N = 5, K = 5) {
      if (arr.length < 2) { const lastVal = Number(arr[arr.length - 1] || 0); return Array(K).fill(lastVal); }
      const data = arr.slice(-N).map(Number);
      const n = data.length;
      let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
      for (let i = 0; i < n; i++) { sumX += i; sumY += data[i]; sumXY += i * data[i]; sumXX += i * i; }
      const denominator = n * sumXX - sumX * sumX;
      const slope = denominator !== 0 ? (n * sumXY - sumX * sumY) / denominator : 0;
      const intercept = (sumY - slope * sumX) / n;
      const predictions = [];
      for (let i = n; i < n + K; i++) { predictions.push(Number((intercept + slope * i).toFixed(2))); }
      return predictions;
    }
    function computeWeeklyForecast(arr, N = 24, K = 7) {
      if (arr.length < 2) { const lastVal = Number(arr[arr.length - 1] || 0); return Array(K).fill(lastVal); }
      const data = arr.slice(-N).map(Number);
      const n = data.length;
      let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
      for (let i = 0; i < n; i++) { sumX += i; sumY += data[i]; sumXY += i * data[i]; sumXX += i * i; }
      const denominator = n * sumXX - sumX * sumX;
      const slope = denominator !== 0 ? (n * sumXY - sumX * sumY) / denominator : 0;
      const intercept = (sumY - slope * sumX) / n;
      const predictions = [];
      for (let i = n; i < n + K; i++) { predictions.push(Number((intercept + slope * i).toFixed(2))); }
      return predictions;
    }
    /***********************
     * REAL-TIME SENSOR SIMULATION WITH REAL-LIFE ANOMALIES
     ***********************/
    function generateSensorData() {
      simulationTime += 1;
      const baseTemp = currentSector.baseTemp;
      const baseHumidity = currentSector.baseHumidity;
      // Regular variation based on sine/cosine functions
      let temperature = baseTemp + Math.sin(simulationTime/10)*2 + ((Math.random()-0.5)*0.2);
      let humidity = baseHumidity + Math.cos(simulationTime/15)*3 + ((Math.random()-0.5)*0.2);
      
      // Introduce a small chance of an anomaly (data passing threshold)
      const anomalyChance = 0.05; // 5% chance
      if (Math.random() < anomalyChance) {
        // Spike temperature by a random value between 3 and 8 degrees
        temperature += Math.random()*5 + 3;
      }
      if (Math.random() < anomalyChance) {
        // Spike humidity by a random value between 5 and 15 percent
        humidity += Math.random()*10 + 5;
      }
      
      temperature = temperature.toFixed(2);
      humidity = humidity.toFixed(2);
      
      const now = new Date();
      const currentTime = now.toLocaleTimeString();
      const timestamp = now.getTime();
      
      // Update dashboard display
      document.getElementById('temperatureValue').textContent = temperature;
      document.getElementById('humidityValue').textContent = humidity;
      document.getElementById('sensorStatus').textContent = "Online";
      
      // Threshold checks
      if (temperature > thresholdTemp && !prevTempAbove) {
        tempWarningCount++; prevTempAbove = true;
        document.getElementById('tempWarningCount').textContent = tempWarningCount;
        document.getElementById('sidebarTempWarnings').textContent = tempWarningCount;
        addWarningLog('Temperature', temperature);
        sendTelegramNotification('Temperature', temperature, currentTime);
      } else if (temperature <= thresholdTemp) { prevTempAbove = false; }
      
      if (humidity > thresholdHumidity && !prevHumAbove) {
        humWarningCount++; prevHumAbove = true;
        document.getElementById('humWarningCount').textContent = humWarningCount;
        document.getElementById('sidebarHumWarnings').textContent = humWarningCount;
        addWarningLog('Humidity', humidity);
        sendTelegramNotification('Humidity', humidity, currentTime);
      } else if (humidity <= thresholdHumidity) { prevHumAbove = false; }
      
      // Update sensor cache (store labels, timestamps, temperatures, and humidities)
      const cache = sectorCache[currentSector.id];
      cache.labels.push(currentTime);
      cache.timestamps.push(timestamp);
      cache.temperatures.push(temperature);
      cache.humidities.push(humidity);
      
      const displayLabels = cache.labels.slice(-maxPoints);
      const displayTemps = cache.temperatures.slice(-maxPoints);
      const displayHum = cache.humidities.slice(-maxPoints);
      temperatureChart.data.labels = displayLabels;
      temperatureChart.data.datasets[0].data = displayTemps;
      humidityChart.data.labels = displayLabels;
      humidityChart.data.datasets[0].data = displayHum;
      
      const tempPredictions = computePredictions(cache.temperatures, 5, 5);
      const humPredictions = computePredictions(cache.humidities, 5, 5);
      temperatureChart.data.datasets[1].data = tempPredictions;
      humidityChart.data.datasets[1].data = humPredictions;
      
      temperatureChart.update();
      humidityChart.update();
      
      // Update bolt health data
      const boltsCount = currentSector.bolts;
      if (!currentSector.boltsHealth) { currentSector.boltsHealth = Array(boltsCount).fill(100); }
      let totalDegradation = 0;
      for (let i = 0; i < boltsCount; i++) {
        let oldHealth = currentSector.boltsHealth[i];
        let degradation = 0;
        if (Number(temperature) > thresholdTemp) {
          degradation += (Number(temperature) - thresholdTemp) * 0.0001;
        }
        if (Number(humidity) > thresholdHumidity) {
          degradation += (Number(humidity) - thresholdHumidity) * 0.0001;
        }
        if (Number(temperature) < thresholdTemp && Number(humidity) < thresholdHumidity) {
          degradation -= 0.00005;
        }
        let newHealth = oldHealth - degradation;
        newHealth = Math.max(0, Math.min(100, newHealth));
        currentSector.boltsHealth[i] = newHealth;
        totalDegradation += degradation;
      }
      currentSector.avgDegradationRate = 0.9 * (currentSector.avgDegradationRate || 0) + 0.1 * (totalDegradation / boltsCount);
      
      // Update bolt health chart
      const boltLabels = [];
      for (let i = 1; i <= boltsCount; i++) { boltLabels.push("Bolt " + i); }
      boltHealthChart.data.labels = boltLabels;
      boltHealthChart.data.datasets[0].data = currentSector.boltsHealth.map(h => Number(h.toFixed(2)));
      const forecastTime = 604800;
      const predictedHealth = currentSector.boltsHealth.map(h => {
        const predicted = h - (currentSector.avgDegradationRate * forecastTime);
        return Number(Math.max(0, Math.min(100, predicted)).toFixed(2));
      });
      boltHealthChart.data.datasets[1].data = predictedHealth;
      boltHealthChart.update();
    }
    setInterval(generateSensorData, 1000);
    /***********************
     * POST PROCESSING FUNCTIONS
     ***********************/
    function detectAnomalies(values) {
      if (values.length < 10) return [];
      const arr = values.slice(-10).map(Number);
      const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
      const std = Math.sqrt(arr.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / arr.length);
      const anomalies = [];
      arr.forEach((val, idx) => { 
        const z = Math.abs(val - mean) / std;
        if (z > 2) anomalies.push({ index: idx, value: val, z: z.toFixed(2) });
      });
      return anomalies;
    }
    function getRollingAverage(values) {
      if (values.length < 10) return null;
      const arr = values.slice(-10).map(Number);
      const avg = arr.reduce((a, b) => a + b, 0) / arr.length;
      return avg.toFixed(2);
    }
    function classifySeverity(count) { return (count >= 3) ? "Critical" : "Warning"; }
    function energyRecommendation(temp, hum) {
      let rec = "";
      rec += (Number(temp) > thresholdTemp) ? "Temperature is high; consider reducing gas flow. " : "Temperature is optimal. ";
      rec += (Number(hum) > thresholdHumidity) ? "Humidity is high; check for condensation." : "Humidity levels are normal.";
      return rec;
    }
    function calculateCorrelation(arrX, arrY) {
      const n = arrX.length;
      const meanX = arrX.reduce((a, b) => a + b, 0) / n;
      const meanY = arrY.reduce((a, b) => a + b, 0) / n;
      let numerator = 0, denomX = 0, denomY = 0;
      for (let i = 0; i < n; i++) {
        const dx = arrX[i] - meanX;
        const dy = arrY[i] - meanY;
        numerator += dx * dy;
        denomX += dx * dx;
        denomY += dy * dy;
      }
      return (numerator / Math.sqrt(denomX * denomY)).toFixed(2);
    }
    function updatePostProcessing() {
      const cache = sectorCache[currentSector.id];
      const tempAnomalies = detectAnomalies(cache.temperatures);
      const humAnomalies = detectAnomalies(cache.humidities);
      let anomalyHTML = "";
      if (tempAnomalies.length === 0 && humAnomalies.length === 0) {
        anomalyHTML = "<p>No anomalies detected in the last 10 readings.</p>";
      } else {
        if (tempAnomalies.length > 0) {
          anomalyHTML += "<p><strong>Temperature anomalies:</strong></p><ul>";
          tempAnomalies.forEach(a => { anomalyHTML += `<li>Value: ${a.value} °C (Z: ${a.z})</li>`; });
          anomalyHTML += "</ul>";
        }
        if (humAnomalies.length > 0) {
          anomalyHTML += "<p><strong>Humidity anomalies:</strong></p><ul>";
          humAnomalies.forEach(a => { anomalyHTML += `<li>Value: ${a.value} % (Z: ${a.z})</li>`; });
          anomalyHTML += "</ul>";
        }
      }
      document.getElementById('anomalyContent').innerHTML = anomalyHTML;
      const tempAvg = getRollingAverage(cache.temperatures);
      const humAvg = getRollingAverage(cache.humidities);
      let trendHTML = `<p>Rolling Average Temperature (last 10 readings): ${tempAvg || "N/A"} °C</p>`;
      trendHTML += `<p>Rolling Average Humidity (last 10 readings): ${humAvg || "N/A"} %</p>`;
      document.getElementById('trendContent').innerHTML = trendHTML;
      const latestTemp = Number(cache.temperatures[cache.temperatures.length - 1] || 0);
      const latestHum = Number(cache.humidities[cache.humidities.length - 1] || 0);
      const tempSeverity = classifySeverity(tempWarningCount);
      const humSeverity = classifySeverity(humWarningCount);
      let severityHTML = `<p>Temperature Severity: <strong>${tempSeverity}</strong></p>`;
      severityHTML += `<p>Humidity Severity: <strong>${humSeverity}</strong></p>`;
      document.getElementById('severityContent').innerHTML = severityHTML;
      const recommendation = energyRecommendation(latestTemp, latestHum);
      document.getElementById('energyContent').innerHTML = `<p>${recommendation}</p>`;
      if (cache.temperatures.length >= 10 && cache.humidities.length >= 10) {
        const temps = cache.temperatures.slice(-10).map(Number);
        const hums = cache.humidities.slice(-10).map(Number);
        const corr = calculateCorrelation(temps, hums);
        document.getElementById('correlationContent').innerHTML = `<p>Pearson correlation coefficient: <strong>${corr}</strong></p>`;
      } else {
        document.getElementById('correlationContent').innerHTML = "<p>Not enough data to compute correlation.</p>";
      }
      let efficiencyScore = 100;
      if (latestTemp > thresholdTemp) { efficiencyScore -= (latestTemp - thresholdTemp) * 5; }
      if (latestHum > thresholdHumidity) { efficiencyScore -= (latestHum - thresholdHumidity) * 3; }
      efficiencyScore = Math.max(0, Math.min(100, efficiencyScore));
      energyGaugeChart.data.datasets[0].data = [efficiencyScore, 100 - efficiencyScore];
      energyGaugeChart.options.plugins.title.text = `Score: ${efficiencyScore}`;
      energyGaugeChart.update();
    }
    setInterval(updatePostProcessing, 5000);
    /***********************
     * UPDATE BOLTS & SECTORS
     ***********************/
    function updateBoltsList() {
      const boltsList = document.getElementById('boltsList');
      boltsList.innerHTML = "";
      for (let i = 1; i <= currentSector.bolts; i++) {
        const li = document.createElement('li');
        li.textContent = "Bolt " + i;
        boltsList.appendChild(li);
      }
    }
    updateBoltsList();
    function updateSectorsList() {
      const sectorsList = document.getElementById('sectorsList');
      sectorsList.innerHTML = "";
      sectors.forEach(sec => {
        const li = document.createElement('li');
        li.setAttribute('data-id', sec.id);
        li.textContent = sec.name + " (" + sec.bolts + " bolts)";
        if (sec.id === currentSector.id) li.classList.add('active');
        sectorsList.appendChild(li);
      });
    }
    updateSectorsList();
    /***********************
     * SECTOR SELECTION HANDLER
     ***********************/
    document.getElementById('sectorsList').addEventListener('click', function(e) {
      if (e.target && e.target.nodeName === "LI") {
        Array.from(this.children).forEach(li => li.classList.remove('active'));
        e.target.classList.add('active');
        const selectedId = e.target.getAttribute('data-id');
        const selectedSector = sectors.find(sec => sec.id === selectedId);
        if (selectedSector) {
          currentSector = selectedSector;
          simulationTime = 0;
          const cache = sectorCache[currentSector.id];
          temperatureChart.data.labels = cache.labels.slice(-maxPoints);
          temperatureChart.data.datasets[0].data = cache.temperatures.slice(-maxPoints);
          temperatureChart.update();
          humidityChart.data.labels = cache.labels.slice(-maxPoints);
          humidityChart.data.datasets[0].data = cache.humidities.slice(-maxPoints);
          humidityChart.update();
          document.getElementById('sectorName').textContent = "Pipeline Sector: " + currentSector.name;
          document.getElementById('boltsCount').textContent = currentSector.bolts;
          if (cache.temperatures.length > 0) {
            document.getElementById('temperatureValue').textContent = cache.temperatures[cache.temperatures.length - 1];
            document.getElementById('humidityValue').textContent = cache.humidities[cache.humidities.length - 1];
          } else {
            document.getElementById('temperatureValue').textContent = '--';
            document.getElementById('humidityValue').textContent = '--';
          }
          tempWarningCount = 0; humWarningCount = 0;
          document.getElementById('tempWarningCount').textContent = tempWarningCount;
          document.getElementById('humWarningCount').textContent = humWarningCount;
          document.getElementById('sidebarTempWarnings').textContent = tempWarningCount;
          document.getElementById('sidebarHumWarnings').textContent = humWarningCount;
          updateBoltsList();
          document.getElementById('postProcessingSector').textContent = "Post Processing for: " + currentSector.name;
          saveState();
        }
      }
    });
    /***********************
     * SIDEBAR NAVIGATION HANDLER
     ***********************/
    const sidebarNavItems = document.querySelectorAll('.nav-menu li');
    sidebarNavItems.forEach(item => {
      item.addEventListener('click', function() {
        sidebarNavItems.forEach(el => el.classList.remove('active'));
        this.classList.add('active');
        const tab = this.getAttribute('data-tab');
        document.getElementById('sectorsTab').style.display = 'none';
        document.getElementById('devicesTab').style.display = 'none';
        document.getElementById('postProcessingTab').style.display = 'none';
        document.getElementById('warningsTab').style.display = 'none';
        document.getElementById('historicalDataTab').style.display = 'none';
        document.getElementById(tab + 'Tab').style.display = 'block';
        document.getElementById('dashboardView').style.display = 'none';
        document.getElementById('warningsView').style.display = 'none';
        document.getElementById('postProcessingView').style.display = 'none';
        document.getElementById('historicalDataView').style.display = 'none';
        if (tab === "warnings") { 
          document.getElementById('warningsView').style.display = 'block'; 
        } else if (tab === "postProcessing") { 
          document.getElementById('postProcessingView').style.display = 'block'; 
        } else if (tab === "historicalData") {
          document.getElementById('historicalDataView').style.display = 'block';
          updateHistoricalChart();
        } else { 
          document.getElementById('dashboardView').style.display = 'block'; 
        }
      });
    });
    /***********************
     * ADD SECTOR HANDLER
     ***********************/
    document.getElementById('addSectorBtn').addEventListener('click', function() {
      let count = prompt("How many bolts do you want to install? (Max = 4)");
      count = parseInt(count);
      if (isNaN(count) || count < 1) { alert("Please enter a valid number (1-4)"); return; }
      if (count > 4) { alert("Maximum bolts allowed is 4."); count = 4; }
      const newSectorId = "sector" + (sectors.length + 1);
      const newSector = { id: newSectorId, name: "Sector " + (sectors.length + 1), bolts: count, baseTemp: 25, baseHumidity: 55, boltsHealth: Array(count).fill(100), avgDegradationRate: 0 };
      sectors.push(newSector);
      sectorCache[newSectorId] = { labels: [], timestamps: [], temperatures: [], humidities: [] };
      updateSectorsList();
      saveState();
    });
    /***********************
     * TOGGLE WARNING DETAILS HANDLER
     ***********************/
    document.querySelectorAll('.toggle-details').forEach(button => {
      button.addEventListener('click', function(e) {
        e.stopPropagation();
        const details = this.parentElement.nextElementSibling;
        if (details.style.display === 'none' || details.style.display === '') { details.style.display = 'block'; this.textContent = 'Hide'; }
        else { details.style.display = 'none'; this.textContent = 'Details'; }
      });
    });
    /***********************
     * WARNING LOG FUNCTIONS
     ***********************/
    function addWarningLog(type, value) {
      const currentTime = new Date().toLocaleTimeString();
      const count = (type === 'Temperature') ? tempWarningCount : humWarningCount;
      const severity = classifySeverity(count);
      const logEntry = { id: Date.now() + Math.random(), time: currentTime, type, value, severity, acknowledged: false, telegramSent: true };
      warningLogs.unshift(logEntry);
      updateWarningLogTable();
      saveState();
    }
    function updateWarningLogTable() {
      const tbody = document.getElementById('warningLogBody');
      tbody.innerHTML = "";
      warningLogs.forEach(log => {
        const tr = document.createElement('tr');
        tr.setAttribute('data-id', log.id);
        if (log.acknowledged) tr.classList.add('acknowledged-row');
        if (log.severity === "Critical") tr.classList.add('critical-row');
        tr.innerHTML = `
          <td>${log.time}</td>
          <td>${log.type}</td>
          <td>${log.value}</td>
          <td>${log.severity}</td>
          <td>${log.acknowledged ? "Acknowledged" : "Active"}</td>
          <td>
            <button class="acknowledge-warning" data-id="${log.id}">Acknowledge</button>
            <button class="resend-telegram" data-id="${log.id}">Resend Telegram</button>
          </td>
        `;
        tbody.appendChild(tr);
      });
    }
    function sendTelegramNotification(type, value, time) {
      console.log(`Telegram notification sent for ${type} at ${time} with value ${value}`);
      if (type === "Temperature") { document.getElementById('tempNotificationStatus').textContent = "Telegram: Sent at " + time; }
      else if (type === "Humidity") { document.getElementById('humNotificationStatus').textContent = "Telegram: Sent at " + time; }
      saveState();
    }
    document.getElementById('warningLogBody').addEventListener('click', function(e) {
      const target = e.target;
      const logId = target.getAttribute('data-id');
      if (target.classList.contains('acknowledge-warning')) {
        warningLogs = warningLogs.map(log => { if (log.id == logId) log.acknowledged = true; return log; });
        updateWarningLogTable();
        saveState();
      } else if (target.classList.contains('resend-telegram')) {
        const logEntry = warningLogs.find(log => log.id == logId);
        if (logEntry) {
          sendTelegramNotification(logEntry.type, logEntry.value, new Date().toLocaleTimeString());
          logEntry.telegramSent = true;
          updateWarningLogTable();
          saveState();
        }
      }
    });
    document.querySelectorAll('.acknowledge-warning').forEach(button => {
      button.addEventListener('click', function(e) { e.stopPropagation(); const type = this.getAttribute('data-type'); alert(`${type} warning acknowledged.`); });
    });
    document.querySelectorAll('.resend-telegram').forEach(button => {
      button.addEventListener('click', function(e) { e.stopPropagation(); const type = this.getAttribute('data-type'); sendTelegramNotification(type, (type === "Temperature" ? document.getElementById('temperatureValue').textContent : document.getElementById('humidityValue').textContent), new Date().toLocaleTimeString()); });
    });
    setInterval(saveState, 5000);
    /***********************
     * INIT UI
     ***********************/
    (function initUI() {
      updateSectorsList();
      updateBoltsList();
      const cache = sectorCache[currentSector.id];
      temperatureChart.data.labels = cache.labels.slice(-maxPoints);
      temperatureChart.data.datasets[0].data = cache.temperatures.slice(-maxPoints);
      temperatureChart.update();
      humidityChart.data.labels = cache.labels.slice(-maxPoints);
      humidityChart.data.datasets[0].data = cache.humidities.slice(-maxPoints);
      humidityChart.update();
      document.getElementById('sectorName').textContent = "Pipeline Sector: " + currentSector.name;
      document.getElementById('boltsCount').textContent = currentSector.bolts;
      document.getElementById('postProcessingSector').textContent = "Post Processing for: " + currentSector.name;
      updateWarningLogTable();
    })();
    /***********************
     * WEEKLY FORECAST UPDATE FUNCTION (Post Processing)
     ***********************/
    function updateWeeklyForecast() {
      const cache = sectorCache[currentSector.id];
      let tempForecast = [], humForecast = [];
      if (cache.temperatures.length >= 24 && cache.humidities.length >= 24) {
        tempForecast = computeWeeklyForecast(cache.temperatures, 24, 7);
        humForecast = computeWeeklyForecast(cache.humidities, 24, 7);
      } else {
        const currentTemp = Number(cache.temperatures[cache.temperatures.length - 1] || 0);
        const currentHum = Number(cache.humidities[cache.humidities.length - 1] || 0);
        tempForecast = Array(7).fill(currentTemp);
        humForecast = Array(7).fill(currentHum);
      }
      weeklyForecastChart.data.datasets[0].data = tempForecast;
      weeklyForecastChart.data.datasets[1].data = humForecast;
      weeklyForecastChart.update();
    }
    setInterval(updateWeeklyForecast, 5000);
    /***********************
     * BOLT HEALTH FORECAST UPDATE FUNCTION (Post Processing)
     ***********************/
    function updateBoltHealthForecast() {
      const boltsCount = currentSector.bolts;
      if (!currentSector.boltsHealth) { currentSector.boltsHealth = Array(boltsCount).fill(100); }
      const forecastTime = 604800;
      const avgDeg = currentSector.avgDegradationRate || 0;
      const currentHealth = currentSector.boltsHealth.map(h => Number(h.toFixed(2)));
      const predictedHealth = currentHealth.map(h => {
        let predicted = h - (avgDeg * forecastTime);
        return Number(Math.max(0, Math.min(100, predicted)).toFixed(2));
      });
      const boltLabels = [];
      for (let i = 1; i <= boltsCount; i++) { boltLabels.push("Bolt " + i); }
      boltHealthChart.data.labels = boltLabels;
      boltHealthChart.data.datasets[0].data = currentHealth;
      boltHealthChart.data.datasets[1].data = predictedHealth;
      boltHealthChart.update();
    }
    setInterval(updateBoltHealthForecast, 5000);
  </script>
</body>
</html>
