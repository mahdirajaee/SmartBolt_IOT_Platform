<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Smart IoT Bolt Platform Dashboard</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700&display=swap" rel="stylesheet" />
  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Chart.js Annotation Plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0"></script>
  <!-- MQTT Client Library -->
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <style>
    /* ========= Global Reset & Base ========= */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Roboto', sans-serif;
      overflow: hidden;
      background: linear-gradient(45deg, #1a2a6c, #b21f1f, #fdbb2d);
      background-size: 600% 600%;
      animation: gradientAnimation 20s ease infinite;
      position: relative;
      color: #fff;
    }
    @keyframes gradientAnimation {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    /* ========= Particle Canvas ========= */
    #particleCanvas {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
    }
    /* ========= Login Form ========= */
    #loginContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.7);
      z-index: 9999;
    }
    .login-form {
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      padding: 30px;
      border-radius: 10px;
      width: 350px;
      box-shadow: 0 15px 25px rgba(0, 0, 0, 0.6);
    }
    .login-form h2 {
      text-align: center;
      margin-bottom: 20px;
      color: #fff;
    }
    .login-form .input-group {
      position: relative;
      margin-bottom: 25px;
    }
    .login-form .input-group input {
      width: 100%;
      padding: 10px 0;
      font-size: 16px;
      color: #fff;
      margin-bottom: 10px;
      border: none;
      border-bottom: 1px solid #fff;
      outline: none;
      background: transparent;
    }
    .login-form .input-group label {
      position: absolute;
      top: 0;
      left: 0;
      padding: 10px 0;
      font-size: 16px;
      color: #fff;
      pointer-events: none;
      transition: 0.5s;
    }
    .login-form .input-group input:focus ~ label,
    .login-form .input-group input:valid ~ label {
      top: -20px;
      left: 0;
      color: #03e9f4;
      font-size: 12px;
    }
    .login-form button {
      width: 100%;
      background: transparent;
      border: 2px solid #03e9f4;
      outline: none;
      padding: 10px 20px;
      cursor: pointer;
      color: #fff;
      font-size: 16px;
      border-radius: 5px;
      position: relative;
      overflow: hidden;
      transition: 0.5s;
      margin-top: 10px;
    }
    .login-form button:hover {
      background: #03e9f4;
      color: #000;
      box-shadow: 0 0 5px #03e9f4,
                 0 0 25px #03e9f4,
                 0 0 50px #03e9f4,
                 0 0 100px #03e9f4;
    }
    /* ========= Sidebar ========= */
    .sidebar {
      position: fixed; top: 0; left: 0; bottom: 0; width: 250px;
      background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(10px);
      padding: 20px; z-index: 1;
    }
    .sidebar h2 { text-align: center; margin-bottom: 20px; font-size: 24px; }
    .nav-menu { list-style: none; padding-left: 0; margin-bottom: 15px; }
    .nav-menu li {
      margin: 10px 0; padding: 8px 12px; background: rgba(255, 255, 255, 0.1);
      border-radius: 5px; cursor: pointer; transition: background 0.3s; font-size: 16px;
    }
    .nav-menu li:hover, .nav-menu li.active { background: rgba(255, 255, 255, 0.3); }
    /* Sidebar Content */
    #sidebarContent > div { display: none; }
    #sectorsTab { display: block; }
    .sector-list { list-style: none; padding-left: 0; margin-top: 10px; }
    .sector-list li {
      padding: 8px 10px; margin: 5px 0; background: rgba(255, 255, 255, 0.1);
      border-radius: 5px; cursor: pointer; transition: background 0.3s; font-size: 14px;
    }
    .sector-list li:hover, .sector-list li.active { background: rgba(255, 255, 255, 0.2); }
    #sectorsTab > .header { display: flex; justify-content: space-between; align-items: center; padding: 0 10px; }
    #sectorsTab h3 { margin: 0; font-size: 16px; }
    #addSectorBtn { font-size: 16px; padding: 2px 6px; cursor: pointer; }
    /* Devices Tab */
    #devicesTab .device-list { list-style: none; padding-left: 0; margin-top: 10px; }
    #devicesTab .device-list li {
      padding: 8px 10px; margin: 5px 0; background: rgba(255, 255, 255, 0.1);
      border-radius: 5px; cursor: pointer; transition: background 0.3s; font-size: 14px;
    }
    #devicesTab .device-list li:hover, #devicesTab .device-list li.active { background: rgba(255, 255, 255, 0.2); }
    /* Post Processing Tab */
    #postProcessingTab { padding: 10px; }
    /* Forecasting Settings Panel */
    #forecastSettings {
      padding: 10px; background: rgba(255,255,255,0.1); margin-bottom: 10px; border-radius: 5px;
    }
    #forecastSettings label { margin-right: 5px; }
    /* Warnings Tab */
    #warningsTab { padding: 10px; }
    #warningsTab h3 { font-size: 18px; margin-bottom: 8px; }
    #warningsTab p { margin-bottom: 5px; }
    /* Historical Data Tab (Sidebar) */
    #historicalDataTab { padding: 10px; display: none; }
    /* ========= Main Content ========= */
    .main-content {
      margin-left: 270px; padding: 20px; height: 100vh; overflow-y: auto; z-index: 1;
    }
    header {
      display: flex; justify-content: space-between; align-items: center;
      background: rgba(0, 0, 0, 0.5); padding: 10px 20px; border-radius: 10px;
      margin-bottom: 20px; backdrop-filter: blur(5px);
    }
    header .search-box input {
      padding: 8px 15px; border: none; border-radius: 20px; outline: none; width: 200px;
    }
    header .user-profile {
      width: 40px; height: 40px; border-radius: 50%; background: #4CAF50;
      display: flex; justify-content: center; align-items: center; font-weight: bold; cursor: pointer;
    }
    header .user-dropdown {
      position: relative;
    }
    header .user-dropdown-content {
      display: none;
      position: absolute;
      right: 0;
      top: 45px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 5px;
      min-width: 150px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
      z-index: 2;
    }
    header .user-dropdown-content a {
      color: #fff;
      padding: 12px 16px;
      text-decoration: none;
      display: block;
      transition: background 0.3s;
    }
    header .user-dropdown-content a:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    /* Views */
    #dashboardView, #warningsView, #postProcessingView, #historicalDataView { display: none; }
    #dashboardView { display: block; }
    .dashboard-cards {
      display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px; margin-bottom: 30px;
    }
    .card {
      background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(5px); border-radius: 10px;
      padding: 20px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      transition: transform 0.3s, box-shadow 0.3s; opacity: 0; animation: fadeInUp 0.5s forwards;
    }
    .card:hover { transform: translateY(-5px); box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4); }
    .card:nth-child(1) { animation-delay: 0.2s; }
    .card:nth-child(2) { animation-delay: 0.3s; }
    .card:nth-child(3) { animation-delay: 0.4s; }
    .card:nth-child(4) { animation-delay: 0.5s; }
    @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    /* Charts Section */
    .charts {
      display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
    }
    .chart-card {
      background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(5px); border-radius: 10px;
      padding: 20px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); animation: fadeInUp 0.5s forwards;
    }
    .chart-card h3 { margin-bottom: 15px; }
    /* Valve Control */
    .valve-control {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
    }
    .valve-status {
      display: flex;
      align-items: center;
    }
    .valve-indicator {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      margin-right: 8px;
    }
    .valve-open {
      background-color: #4CAF50;
    }
    .valve-closed {
      background-color: #f44336;
    }
    .valve-button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    .open-valve {
      background-color: #4CAF50;
      color: white;
    }
    .open-valve:hover {
      background-color: #45a049;
    }
    .close-valve {
      background-color: #f44336;
      color: white;
    }
    .close-valve:hover {
      background-color: #d32f2f;
    }
    /* Enlarged Weekly Forecast Card */
    #weeklyForecastCard {
      grid-column: span 2;
      padding: 30px;
      min-height: 450px;
    }
    #weeklyForecastChart {
      width: 100% !important;
      height: 400px !important;
    }
    /* Post Processing View */
    #postProcessingView header { margin-bottom: 10px; }
    #postProcessingSector { font-size: 18px; margin-bottom: 10px; text-align: center; }
    /* Warnings View */
    #warningsView h2 { margin-bottom: 20px; }
    .warning-card {
      background: rgba(0, 0, 0, 0.5); border-left: 5px solid; border-radius: 8px;
      margin-bottom: 15px; padding: 10px 15px; transition: background 0.3s, transform 0.3s; position: relative;
    }
    #tempWarningCard { border-color: red; }
    #pressureWarningCard { border-color: orange; }
    .warning-card:hover { background: rgba(0, 0, 0, 0.6); transform: scale(1.02); }
    .warning-header { display: flex; align-items: center; justify-content: space-between; cursor: pointer; }
    .warning-header h3 { margin: 0; font-size: 18px; flex-grow: 1; padding-left: 10px; }
    .warning-icon { font-size: 22px; }
    .warning-details {
      padding-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.3);
      margin-top: 8px; font-size: 14px; color: #f1f1f1;
    }
    .toggle-details, .acknowledge-warning, .resend-telegram {
      background: transparent; border: 1px solid #fff; border-radius: 4px;
      color: #fff; font-size: 14px; cursor: pointer; padding: 3px 6px; margin-left: 5px; outline: none;
    }
    .notification-status { font-size: 12px; margin-top: 5px; color: #ccc; }
    /* Warning Log */
    #warningLog { margin-top: 20px; }
    #warningLog h3 { margin-bottom: 10px; }
    .warning-log-container {
      max-height: 250px; overflow-y: auto; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px;
    }
    .warning-log-container table {
      width: 100%; border-collapse: collapse; font-size: 13px; color: #fff;
    }
    .warning-log-container th, .warning-log-container td {
      padding: 6px; border: 1px solid rgba(255,255,255,0.2); text-align: center;
    }
    .acknowledged-row { background: rgba(0, 128, 0, 0.3); text-decoration: line-through; }
    .critical-row { background: rgba(255, 0, 0, 0.3); }
    /* Responsive */
    @media (max-width: 768px) {
      .main-content { margin-left: 0; }
      .charts { grid-template-columns: 1fr; }
      #weeklyForecastCard { grid-column: span 1; }
    }
  </style>
</head>
<body>
  <!-- Particle Background Canvas -->
  <canvas id="particleCanvas"></canvas>

  <!-- Login Container -->
  <div id="loginContainer">
    <div class="login-form">
      <h2>Smart IoT Bolt Platform</h2>
      <form id="loginForm">
        <div class="input-group">
          <input type="text" id="username" required>
          <label for="username">Username</label>
        </div>
        <div class="input-group">
          <input type="password" id="password" required>
          <label for="password">Password</label>
        </div>
        <button type="submit">Login</button>
      </form>
    </div>
  </div>

  <!-- Main Dashboard (Initially Hidden) -->
  <div id="mainDashboard" style="display: none;">
    <!-- Sidebar Navigation -->
    <div class="sidebar">
      <h2>Smart IoT Bolt</h2>
      <ul class="nav-menu">
        <li data-tab="sectors" class="active">Sectors</li>
        <li data-tab="devices">Devices</li>
        <li data-tab="postProcessing">Post Processing</li>
        <li data-tab="warnings">Warnings</li>
        <li data-tab="historicalData">Historical Data</li>
      </ul>
      <div id="sidebarContent">
        <!-- Sectors Tab -->
        <div id="sectorsTab">
          <div class="header">
            <h3>Sectors</h3>
            <button id="addSectorBtn">+</button>
          </div>
          <ul class="sector-list" id="sectorsList"><!-- Dynamically populated --></ul>
        </div>
        <!-- Devices Tab -->
        <div id="devicesTab">
          <ul class="device-list" id="boltsList"><!-- Dynamically populated --></ul>
        </div>
        <!-- Post Processing Tab -->
        <div id="postProcessingTab">
          <p style="padding:10px;">Analytics for the selected sector are shown in the main area below.</p>
        </div>
        <!-- Warnings Tab -->
        <div id="warningsTab">
          <div>
            <h3>Warning Summary</h3>
            <p><span style="color:red; font-weight:bold;">Temperature:</span> <span id="sidebarTempWarnings">0</span> occurrences</p>
            <p><span style="color:orange; font-weight:bold;">Pressure:</span> <span id="sidebarPressureWarnings">0</span> occurrences</p>
          </div>
        </div>
        <!-- Historical Data Tab (Sidebar) -->
        <div id="historicalDataTab">
          <p style="padding:10px;">View full historical sensor data here.</p>
        </div>
      </div>
    </div>
    <!-- Main Content Area -->
    <div class="main-content">
      <!-- Dashboard View -->
      <div id="dashboardView">
        <header>
          <div class="search-box"><input type="text" placeholder="Search sectors..." /></div>
          <div class="user-dropdown">
            <div class="user-profile" id="userProfileBtn">A</div>
            <div class="user-dropdown-content" id="userDropdown">
              <a href="#" id="profileLink">Profile</a>
              <a href="#" id="settingsLink">Settings</a>
              <a href="#" id="logoutLink">Logout</a>
            </div>
          </div>
        </header>
        <section class="dashboard-cards" id="dashboardCards">
          <div class="card" id="sectorCard">
            <h3 id="sectorName">Pipeline Sector: N/A</h3>
            <p>Sensor Bolts Installed: <strong id="boltsCount">--</strong></p>
            <p>Status: <strong id="sensorStatus" style="color: #4CAF50;">Online</strong></p>
            <p>Temperature: <strong id="temperatureValue">--</strong> °C</p>
            <p>Pressure: <strong id="pressureValue">--</strong> kPa</p>
            <div class="valve-control">
              <div class="valve-status">
                <div class="valve-indicator valve-open" id="valveIndicator"></div>
                <span id="valveStatusText">Valve Open</span>
              </div>
              <button class="valve-button close-valve" id="valveToggleBtn">Close Valve</button>
            </div>
          </div>
        </section>
        <section class="charts">
          <div class="chart-card">
            <h3>Temperature Over Time</h3>
            <canvas id="temperatureChart"></canvas>
          </div>
          <div class="chart-card">
            <h3>Pressure Over Time</h3>
            <canvas id="pressureChart"></canvas>
          </div>
        </section>
      </div>
      <!-- Warnings View -->
      <div id="warningsView">
        <header>
          <div class="search-box"><input type="text" placeholder="Search warnings..." /></div>
          <div class="user-profile">A</div>
        </header>
        <h2>Warnings</h2>
        <div class="warning-card" id="tempWarningCard">
          <div class="warning-header">
            <span class="warning-icon">⚠️</span>
            <h3>Temperature Threshold Exceeded</h3>
            <button class="toggle-details">Details</button>
          </div>
          <div class="warning-details" style="display:none;">
            <p>Exceeded <span id="tempWarningCount">0</span> time(s).</p>
            <p class="notification-status" id="tempNotificationStatus">Telegram: Not Sent</p>
            <div style="margin-top:5px;">
              <button class="acknowledge-warning" data-type="Temperature">Acknowledge</button>
              <button class="resend-telegram" data-type="Temperature">Resend Telegram</button>
            </div>
          </div>
        </div>
        <div class="warning-card" id="pressureWarningCard">
          <div class="warning-header">
            <span class="warning-icon">⚠️</span>
            <h3>Pressure Threshold Exceeded</h3>
            <button class="toggle-details">Details</button>
          </div>
          <div class="warning-details" style="display:none;">
            <p>Exceeded <span id="pressureWarningCount">0</span> time(s).</p>
            <p class="notification-status" id="pressureNotificationStatus">Telegram: Not Sent</p>
            <div style="margin-top:5px;">
              <button class="acknowledge-warning" data-type="Pressure">Acknowledge</button>
              <button class="resend-telegram" data-type="Pressure">Resend Telegram</button>
            </div>
          </div>
        </div>
        <div id="warningLog">
          <h3>Warning Log</h3>
          <div class="warning-log-container">
            <table>
              <thead>
                <tr>
                  <th>Time</th>
                  <th>Type</th>
                  <th>Value</th>
                  <th>Severity</th>
                  <th>Status</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="warningLogBody"><!-- Dynamically populated --></tbody>
            </table>
          </div>
        </div>
      </div>
      <!-- Post Processing View -->
      <div id="postProcessingView" style="display:none">
        <header>
          <div class="search-box"><input type="text" placeholder="Search analytics..." /></div>
          <div class="user-profile">A</div>
        </header>
        <h3 id="postProcessingSector" style="text-align:center; margin-bottom:10px;">Post Processing for: N/A</h3>
        <!-- Forecasting Settings Panel -->
        <div id="forecastSettings">
          <label for="dataWindow">Data Window (readings):</label>
          <input type="number" id="dataWindow" value="10" min="1" max="100" style="width: 60px;" />
          <label for="forecastHorizon">Forecast Horizon (predictions):</label>
          <input type="number" id="forecastHorizon" value="5" min="1" max="100" style="width: 60px;" />
          <button id="applyForecastSettings">Apply</button>
        </div>
        <section class="dashboard-cards" id="postProcessingCards">
          <div class="card" id="anomalyCard">
            <h3>Anomaly Detection</h3>
            <div id="anomalyContent"><!-- Anomaly info --></div>
          </div>
          <div class="card" id="trendCard">
            <h3>Trend Analysis</h3>
            <div id="trendContent"><!-- Trend info --></div>
          </div>
          <div class="card" id="severityCard">
            <h3>Severity Alerts</h3>
            <div id="severityContent"><!-- Severity info --></div>
          </div>
          <div class="card" id="energyCard">
            <h3>Energy Efficiency Recommendations</h3>
            <div id="energyContent"><!-- Recommendation info --></div>
          </div>
          <div class="card" id="correlationCard">
            <h3>Correlation Analysis</h3>
            <div id="correlationContent"><!-- Correlation info --></div>
          </div>
          <div class="card" id="energyGaugeCard">
            <h3>Energy Efficiency Score</h3>
            <canvas id="energyGaugeChart"></canvas>
          </div>
          <!-- Enlarged Weekly Forecast Card -->
          <div class="card" id="weeklyForecastCard">
            <h3>Weekly Forecast</h3>
            <canvas id="weeklyForecastChart"></canvas>
          </div>
        </section>
      </div>
      <!-- Historical Data View -->
      <div id="historicalDataView" style="display:none;">
        <header>
          <div class="search-box"><input type="text" placeholder="Search historical data..." /></div>
          <div class="user-profile">A</div>
        </header>
        <h2>Historical Data</h2>
        <!-- Filter and Download Controls -->
        <div id="historicalControls" style="margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
          <label for="filterSelect" style="font-size: 16px;">Filter:</label>
          <select id="filterSelect" style="padding: 5px 10px; border-radius: 4px; border: none;">
            <option value="all">All</option>
            <option value="hourly">Hourly</option>
            <option value="daily">Daily</option>
            <option value="weekly">Weekly</option>
            <option value="monthly">Monthly</option>
          </select>
          <button id="downloadDataBtn" style="padding: 5px 10px; border-radius: 4px; border: none; background-color: #4caf50; color: #fff; cursor: pointer;">Download Data</button>
        </div>
        <div class="chart-card">
          <h3>Historical Temperature & Pressure</h3>
          <canvas id="historicalDataChart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * AUTHENTICATION & USER MANAGEMENT
     ***********************/
    let isAuthenticated = false;
    let currentUser = null;
    const apiBaseUrl = 'http://your-api-base-url.com/api'; // Replace with your actual API base URL
    
    // Check if user is already logged in (token in localStorage)
    function checkAuthState() {
      const token = localStorage.getItem('auth_token');
      if (token) {
        // Validate token with the server
        fetch(`${apiBaseUrl}/account/validate`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`
          }
        })
        .then(response => {
          if (response.ok) {
            return response.json();
          } else {
            throw new Error('Invalid token');
          }
        })
        .then(data => {
          isAuthenticated = true;
          currentUser = data.user;
          showDashboard();
          updateUserProfile();
        })
        .catch(error => {
          console.error('Authentication error:', error);
          localStorage.removeItem('auth_token');
          showLoginForm();
        });
      } else {
        showLoginForm();
      }
    }

    // Login form submission
    document.getElementById('loginForm').addEventListener('submit', function(e) {
      e.preventDefault();
      
      const username = document.getElementById('username').value;
      const password = document.getElementById('password').value;
      
      // Send login request to Account Manager
      fetch(`${apiBaseUrl}/account/login`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          username: username,
          password: password
        })
      })
      .then(response => {
        if (response.ok) {
          return response.json();
        } else {
          throw new Error('Login failed');
        }
      })
      .then(data => {
        localStorage.setItem('auth_token', data.token);
        isAuthenticated = true;
        currentUser = data.user;
        showDashboard();
        updateUserProfile();
      })
      .catch(error => {
        alert('Login failed. Please check your credentials.');
        console.error('Login error:', error);
      });
    });

    // Show login form
    function showLoginForm() {
      document.getElementById('loginContainer').style.display = 'flex';
      document.getElementById('mainDashboard').style.display = 'none';
    }

    // Show dashboard after successful login
    function showDashboard() {
      document.getElementById('loginContainer').style.display = 'none';
      document.getElementById('mainDashboard').style.display = 'block';
      initializeAllCharts();
      fetchInitialData();
      connectMQTT();
    }

    // Update user profile information
    function updateUserProfile() {
      const userInitial = currentUser.name.charAt(0).toUpperCase();
      document.querySelectorAll('.user-profile').forEach(el => {
        el.textContent = userInitial;
      });
    }

    // Logout functionality
    document.getElementById('logoutLink').addEventListener('click', function(e) {
      e.preventDefault();
      localStorage.removeItem('auth_token');
      isAuthenticated = false;
      currentUser = null;
      showLoginForm();
      disconnectMQTT();
    });

    // User dropdown toggle
    document.getElementById('userProfileBtn').addEventListener('click', function() {
      document.getElementById('userDropdown').style.display = 
        document.getElementById('userDropdown').style.display === 'block' ? 'none' : 'block';
    });

    // Close dropdown when clicking elsewhere
    window.addEventListener('click', function(e) {
      if (!e.target.matches('#userProfileBtn')) {
        const dropdown = document.getElementById('userDropdown');
        if (dropdown.style.display === 'block') {
          dropdown.style.display = 'none';
        }
      }
    });

    /***********************
     * STATE PERSISTENCE FUNCTIONS
     ***********************/
    function loadState() {
      const stateStr = localStorage.getItem('dashboardState');
      if (stateStr) {
        try {
          const state = JSON.parse(stateStr);
          if (state.sectors) { sectors = state.sectors; }
          if (state.currentSectorId) { currentSector = sectors.find(sec => sec.id === state.currentSectorId) || sectors[0]; }
          simulationTime = state.simulationTime || 0;
          tempWarningCount = state.tempWarningCount || 0;
          pressureWarningCount = state.pressureWarningCount || 0;
          warningLogs = state.warningLogs || [];
          sectorCache = state.sectorCache || {};
          sectors.forEach(sec => { 
            if (!sectorCache[sec.id]) { 
              sectorCache[sec.id] = { labels: [], timestamps: [], temperatures: [], pressures: [] }; 
            } else if (!sectorCache[sec.id].timestamps) {
              sectorCache[sec.id].timestamps = [];
            }
            if (!sec.boltsHealth) {
              sec.boltsHealth = Array(sec.bolts).fill(100);
              sec.avgDegradationRate = 0;
            }
          });
          console.log("State loaded from localStorage.");
        } catch (err) { console.error("Error loading state:", err); }
      }
    }
    
    function saveState() {
      const state = { sectors, currentSectorId: currentSector ? currentSector.id : null, simulationTime, tempWarningCount, pressureWarningCount, warningLogs, sectorCache };
      localStorage.setItem('dashboardState', JSON.stringify(state));
    }

    /***********************
     * MQTT CONNECTION SETUP
     ***********************/
    let mqttClient = null;
    const mqttHost = 'your-mqtt-broker-address'; // Replace with your actual MQTT broker
    const mqttPort = 9001; // WebSocket port
    const mqttUsername = 'your-mqtt-username';  // Replace with your MQTT credentials
    const mqttPassword = 'your-mqtt-password';

    function connectMQTT() {
      const clientId = 'web_dashboard_' + Math.random().toString(16).substr(2, 8);
      const connectUrl = `mqtt://${mqttHost}:${mqttPort}`;
      
      try {
        mqttClient = mqtt.connect(connectUrl, {
          clientId,
          clean: true,
          username: mqttUsername,
          password: mqttPassword,
          connectTimeout: 4000,
          reconnectPeriod: 1000
        });

        mqttClient.on('connect', () => {
          console.log('Connected to MQTT broker');
          // Subscribe to all sector data topics
          sectors.forEach(sector => {
            subscribeSectorTopics(sector.id);
          });
        });

        mqttClient.on('message', (topic, message) => {
          handleMQTTMessage(topic, message);
        });

        mqttClient.on('error', (error) => {
          console.error('MQTT Connection Error:', error);
        });
      } catch (error) {
        console.error('MQTT Connection Failed:', error);
      }
    }

    function disconnectMQTT() {
      if (mqttClient && mqttClient.connected) {
        mqttClient.end();
        console.log('Disconnected from MQTT broker');
      }
    }

    function subscribeSectorTopics(sectorId) {
      if (mqttClient && mqttClient.connected) {
        mqttClient.subscribe(`sensors/${sectorId}/temperature`, { qos: 0 });
        mqttClient.subscribe(`sensors/${sectorId}/pressure`, { qos: 0 });
        mqttClient.subscribe(`actuators/${sectorId}/valve`, { qos: 0 });
        console.log(`Subscribed to sector ${sectorId} topics`);
      }
    }

    function handleMQTTMessage(topic, message) {
      const topicParts = topic.split('/');
      if (topicParts.length < 3) return;
      
      const sectorId = topicParts[1];
      const dataType = topicParts[2];
      const value = message.toString();
      
      console.log(`Received data for ${sectorId}/${dataType}: ${value}`);
      
      if (currentSector && currentSector.id === sectorId) {
        // Update UI based on message type
        if (dataType === 'temperature') {
          document.getElementById('temperatureValue').textContent = value;
          checkThresholds('temperature', value);
          addDataPoint('temperature', value);
        } else if (dataType === 'pressure') {
          document.getElementById('pressureValue').textContent = value;
          checkThresholds('pressure', value);
          addDataPoint('pressure', value);
        } else if (dataType === 'valve') {
          updateValveStatus(value === 'open');
        }
      }
      
      // Cache data for historical records
      if (sectorCache[sectorId]) {
        const now = new Date();
        const timeStr = now.toLocaleTimeString();
        const timestamp = now.getTime();
        
        if (dataType === 'temperature') {
          sectorCache[sectorId].temperatures.push(value);
          if (sectorCache[sectorId].labels.length < sectorCache[sectorId].temperatures.length) {
            sectorCache[sectorId].labels.push(timeStr);
            sectorCache[sectorId].timestamps.push(timestamp);
          }
        } else if (dataType === 'pressure') {
          sectorCache[sectorId].pressures.push(value);
        }
      }
    }

    /***********************
     * GLOBAL VARIABLES & SECTOR SETUP
     ***********************/
    let sectors = [ { id: 'sector1', name: 'Sector 1', bolts: 3, baseTemp: 25, basePressure: 100, boltsHealth: Array(3).fill(100), avgDegradationRate: 0 } ];
    let currentSector = sectors[0];
    let simulationTime = 0;
    let thresholdTemp = 28; // °C
    let thresholdPressure = 105; // kPa
    let tempWarningCount = 0, pressureWarningCount = 0;
    let prevTempAbove = false, prevPressureAbove = false;
    let valveOpen = true;
    // Alert control: send a high-priority alert after 3 consecutive threshold breaches.
    const thresholdAlertCount = 3;
    let tempAlertSent = false, pressureAlertSent = false;
    let warningLogs = [];
    const maxPoints = 20;
    let sectorCache = {};
    sectors.forEach(sec => {
      if (!sectorCache[sec.id]) {
        sectorCache[sec.id] = { labels: [], timestamps: [], temperatures: [], pressures: [] };
      } else if (!sectorCache[sec.id].timestamps) {
        sectorCache[sec.id].timestamps = [];
      }
    });
    // Forecasting parameters (number of recent readings and prediction horizon)
    let forecastDataWindow = 10;
    let forecastHorizon = 5;
    loadState();

    /***********************
     * PARTICLE ANIMATION
     ***********************/
    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d');
    let particles = [];
    const particleCount = 100;
    
    function resizeCanvas() { 
      canvas.width = window.innerWidth; 
      canvas.height = window.innerHeight; 
    }
    
    window.addEventListener('resize', resizeCanvas); 
    resizeCanvas();
    
    function initParticles() {
      particles = [];
      for (let i = 0; i < particleCount; i++) {
        particles.push({ 
          x: Math.random()*canvas.width, 
          y: Math.random()*canvas.height,
          vx: (Math.random()-0.5)*0.5, 
          vy: (Math.random()-0.5)*0.5,
          radius: Math.random()*2+1, 
          opacity: Math.random()*0.5+0.3 
        });
      }
    }
    
    initParticles();
    
    function animateParticles() {
      ctx.clearRect(0,0,canvas.width, canvas.height);
      particles.forEach(p => {
        p.x += p.vx; p.y += p.vy;
        if (p.x < 0 || p.x > canvas.width) p.vx = -p.vx;
        if (p.y < 0 || p.y > canvas.height) p.vy = -p.vy;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
        ctx.fillStyle = `rgba(255,255,255,${p.opacity})`;
        ctx.fill();
      });
      requestAnimationFrame(animateParticles);
    }
    
    animateParticles();

    /***********************
     * INITIALIZE ALL CHARTS
     ***********************/
    let temperatureChart, pressureChart, energyGaugeChart, weeklyForecastChart, historicalChart;

    function initializeAllCharts() {
      initializeTemperatureChart();
      initializePressureChart();
      initializeEnergyGaugeChart();
      initializeWeeklyForecastChart();
      initializeHistoricalChart();
    }

    function initializeTemperatureChart() {
      const tempCtx = document.getElementById('temperatureChart').getContext('2d');
      const tempGradient = tempCtx.createLinearGradient(0,0,0,400);
      tempGradient.addColorStop(0, 'rgba(255, 99, 132, 0.5)');
      tempGradient.addColorStop(1, 'rgba(255, 159, 64, 0.1)');
      
      temperatureChart = new Chart(tempCtx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Temperature (°C)',
              data: [],
              backgroundColor: tempGradient,
              borderColor: 'rgba(255, 99, 132, 1)',
              borderWidth: 2,
              tension: 0.4,
              fill: true,
              pointRadius: 4,
              pointHoverRadius: 6,
              pointBackgroundColor: 'rgba(255, 99, 132, 1)'
            },
            {
              label: 'Short-term Prediction',
              data: [],
              borderColor: 'rgba(255, 99, 132, 0.7)',
              borderDash: [6, 6],
              borderWidth: 2,
              tension: 0.4,
              fill: false,
              pointRadius: 0,
              pointHoverRadius: 0
            }
          ]
        },
        options: {
          responsive: true,
          animation: { duration: 500 },
          plugins: {
            tooltip: { mode: 'index', intersect: false },
            annotation: {
              annotations: {
                thresholdLine: {
                  type: 'line',
                  yMin: thresholdTemp,
                  yMax: thresholdTemp,
                  borderColor: 'red',
                  borderWidth: 2,
                  label: { enabled: true, content: 'Temp Threshold', backgroundColor: 'rgba(255,0,0,0.7)' }
                }
              }
            },
            legend: { labels: { color: '#fff' } }
          },
          scales: {
            x: { display: true, title: { display: true, text: 'Time', color: '#fff' },
                 grid: { color: 'rgba(255,255,255,0.2)' }, ticks: { color: '#fff' } },
            y: { display: true, title: { display: true, text: 'Temperature (°C)', color: '#fff' },
                 grid: { color: 'rgba(255,255,255,0.2)' }, ticks: { color: '#fff' } }
          }
        }
      });
    }

    function initializePressureChart() {
      const pressureCtx = document.getElementById('pressureChart').getContext('2d');
      const pressureGradient = pressureCtx.createLinearGradient(0,0,0,400);
      pressureGradient.addColorStop(0, 'rgba(54, 162, 235, 0.5)');
      pressureGradient.addColorStop(1, 'rgba(75, 192, 192, 0.1)');
      
      pressureChart = new Chart(pressureCtx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Pressure (kPa)',
              data: [],
              backgroundColor: pressureGradient,
              borderColor: 'rgba(54, 162, 235, 1)',
              borderWidth: 2,
              tension: 0.4,
              fill: true,
              pointRadius: 4,
              pointHoverRadius: 6,
              pointBackgroundColor: 'rgba(54, 162, 235, 1)'
            },
            {
              label: 'Short-term Prediction',
              data: [],
              borderColor: 'rgba(54, 162, 235, 0.7)',
              borderDash: [6, 6],
              borderWidth: 2,
              tension: 0.4,
              fill: false,
              pointRadius: 0,
              pointHoverRadius: 0
            }
          ]
        },
        options: {
          responsive: true,
          animation: { duration: 500 },
          plugins: {
            tooltip: { mode: 'index', intersect: false },
            annotation: {
              annotations: {
                thresholdLine: {
                  type: 'line',
                  yMin: thresholdPressure,
                  yMax: thresholdPressure,
                  borderColor: 'orange',
                  borderWidth: 2,
                  label: { enabled: true, content: 'Pressure Threshold', backgroundColor: 'rgba(255,165,0,0.7)' }
                }
              }
            },
            legend: { labels: { color: '#fff' } }
          },
          scales: {
            x: { display: true, title: { display: true, text: 'Time', color: '#fff' },
                 grid: { color: 'rgba(255,255,255,0.2)' }, ticks: { color: '#fff' } },
            y: { display: true, title: { display: true, text: 'Pressure (kPa)', color: '#fff' },
                 grid: { color: 'rgba(255,255,255,0.2)' }, ticks: { color: '#fff' } }
          }
        }
      });
    }

    function initializeEnergyGaugeChart() {
      const energyGaugeCtx = document.getElementById('energyGaugeChart').getContext('2d');
      energyGaugeChart = new Chart(energyGaugeCtx, {
        type: 'doughnut',
        data: { datasets: [{ data: [100, 0], backgroundColor: ['#4caf50', '#ddd'], borderWidth: 0 }] },
        options: {
          rotation: -90 * Math.PI / 180,
          circumference: 180 * Math.PI / 180,
          cutout: '70%',
          plugins: { tooltip: { enabled: false }, legend: { display: false },
            title: { display: true, text: 'Score', position: 'bottom', color: '#fff', font: { size: 16 } }
          }
        }
      });
    }

    function initializeWeeklyForecastChart() {
      const weeklyForecastCtx = document.getElementById('weeklyForecastChart').getContext('2d');
      weeklyForecastChart = new Chart(weeklyForecastCtx, {
        type: 'line',
        data: {
          labels: ['Day 1','Day 2','Day 3','Day 4','Day 5','Day 6','Day 7'],
          datasets: [
            {
              label: 'Temperature Forecast (°C)',
              data: [],
              borderColor: 'rgba(255, 99, 132, 1)',
              backgroundColor: 'rgba(255, 99, 132, 0.2)',
              borderWidth: 2,
              tension: 0.4,
              fill: true
            },
            {
              label: 'Pressure Forecast (kPa)',
              data: [],
              borderColor: 'rgba(54, 162, 235, 1)',
              backgroundColor: 'rgba(54, 162, 235, 0.2)',
              borderWidth: 2,
              tension: 0.4,
              fill: true
            }
          ]
        },
        options: {
          responsive: true,
          plugins: { legend: { labels: { color: '#fff' } } },
          scales: {
            x: { title: { display: true, text: 'Day', color: '#fff' },
                 grid: { color: 'rgba(255,255,255,0.2)' }, ticks: { color: '#fff' } },
            y: { title: { display: true, text: 'Value', color: '#fff' },
                 grid: { color: 'rgba(255,255,255,0.2)' }, ticks: { color: '#fff' } }
          }
        }
      });
    }

    function initializeHistoricalChart() {
      const historicalCtx = document.getElementById('historicalDataChart').getContext('2d');
      historicalChart = new Chart(historicalCtx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Temperature (°C)',
              data: [],
              borderColor: 'rgba(255, 99, 132, 1)',
              backgroundColor: 'rgba(255, 99, 132, 0.2)',
              fill: true,
              tension: 0.4,
              pointRadius: 2
            },
            {
              label: 'Pressure (kPa)',
              data: [],
              borderColor: 'rgba(54, 162, 235, 1)',
              backgroundColor: 'rgba(54, 162, 235, 0.2)',
              fill: true,
              tension: 0.4,
              pointRadius: 2
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { labels: { color: '#fff', font: { size: 14 } } },
            tooltip: { mode: 'index', intersect: false }
          },
          scales: {
            x: {
              type: 'category',
              title: { display: true, text: 'Time', color: '#fff', font: { size: 16 } },
              grid: { color: 'rgba(255,255,255,0.1)' },
              ticks: { color: '#fff', autoSkip: true, maxTicksLimit: 20 }
            },
            y: {
              title: { display: true, text: 'Value', color: '#fff', font: { size: 16 } },
              grid: { color: 'rgba(255,255,255,0.1)' },
              ticks: { color: '#fff' }
            }
          },
          elements: { line: { tension: 0.4 } }
        }
      });
    }

    /***********************
     * DATA HANDLING FUNCTIONS
     ***********************/
    function fetchInitialData() {
      // Fetch initial sector data from Resource Catalog
      fetch(`${apiBaseUrl}/catalog/sectors`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        }
      })
      .then(response => response.json())
      .then(data => {
        if (data.sectors && data.sectors.length > 0) {
          sectors = data.sectors;
          currentSector = sectors[0];
          updateSectorsList();
          fetchSectorData(currentSector.id);
        }
      })
      .catch(error => {
        console.error('Error fetching sectors:', error);
      });
      
      // Fetch thresholds from Resource Catalog
      fetch(`${apiBaseUrl}/catalog/thresholds`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        }
      })
      .then(response => response.json())
      .then(data => {
        if (data.temperature) thresholdTemp = data.temperature;
        if (data.pressure) thresholdPressure = data.pressure;
        
        // Update chart annotations
        if (temperatureChart && temperatureChart.options.plugins.annotation.annotations.thresholdLine) {
          temperatureChart.options.plugins.annotation.annotations.thresholdLine.yMin = thresholdTemp;
          temperatureChart.options.plugins.annotation.annotations.thresholdLine.yMax = thresholdTemp;
          temperatureChart.update();
        }
        
        if (pressureChart && pressureChart.options.plugins.annotation.annotations.thresholdLine) {
          pressureChart.options.plugins.annotation.annotations.thresholdLine.yMin = thresholdPressure;
          pressureChart.options.plugins.annotation.annotations.thresholdLine.yMax = thresholdPressure;
          pressureChart.update();
        }
      })
      .catch(error => {
        console.error('Error fetching thresholds:', error);
      });
    }

    function fetchSectorData(sectorId) {
      // Fetch latest sensor readings for the sector from Time Series DB
      fetch(`${apiBaseUrl}/timeseries/${sectorId}/latest`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        }
      })
      .then(response => response.json())
      .then(data => {
        if (data.temperature) {
          document.getElementById('temperatureValue').textContent = data.temperature;
        }
        if (data.pressure) {
          document.getElementById('pressureValue').textContent = data.pressure;
        }
        if (data.valve !== undefined) {
          updateValveStatus(data.valve === 'open');
        }
      })
      .catch(error => {
        console.error('Error fetching sector data:', error);
      });
      
      // Fetch historical data for charts
      fetch(`${apiBaseUrl}/timeseries/${sectorId}/history?limit=${maxPoints}`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        }
      })
      .then(response => response.json())
      .then(data => {
        if (data.readings && data.readings.length > 0) {
          const cache = sectorCache[sectorId] || { labels: [], timestamps: [], temperatures: [], pressures: [] };
          
          cache.labels = data.readings.map(r => new Date(r.timestamp).toLocaleTimeString());
          cache.timestamps = data.readings.map(r => r.timestamp);
          cache.temperatures = data.readings.map(r => r.temperature);
          cache.pressures = data.readings.map(r => r.pressure);
          
          sectorCache[sectorId] = cache;
          
          updateCharts();
        }
      })
      .catch(error => {
        console.error('Error fetching historical data:', error);
      });
      
      // Fetch warnings count
      fetch(`${apiBaseUrl}/warnings/${sectorId}/count`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        }
      })
      .then(response => response.json())
      .then(data => {
        if (data.temperature !== undefined) {
          tempWarningCount = data.temperature;
          document.getElementById('tempWarningCount').textContent = tempWarningCount;
          document.getElementById('sidebarTempWarnings').textContent = tempWarningCount;
        }
        if (data.pressure !== undefined) {
          pressureWarningCount = data.pressure;
          document.getElementById('pressureWarningCount').textContent = pressureWarningCount;
          document.getElementById('sidebarPressureWarnings').textContent = pressureWarningCount;
        }
      })
      .catch(error => {
        console.error('Error fetching warnings count:', error);
      });
      
      // Fetch warning logs
      fetch(`${apiBaseUrl}/warnings/${sectorId}/logs`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        }
      })
      .then(response => response.json())
      .then(data => {
        if (data.logs) {
          warningLogs = data.logs;
          updateWarningLogTable();
        }
      })
      .catch(error => {
        console.error('Error fetching warning logs:', error);
      });
    }

    function addDataPoint(type, value) {
      if (!currentSector) return;
      
      const now = new Date();
      const timeStr = now.toLocaleTimeString();
      const timestamp = now.getTime();
      
      const cache = sectorCache[currentSector.id];
      
      // Add new data point
      if (type === 'temperature') {
        cache.temperatures.push(value);
        // Only add label and timestamp if this is the first point or if both temp and pressure arrived
        if (cache.labels.length < cache.temperatures.length || 
            (cache.pressures.length === cache.temperatures.length && 
             cache.labels.length < cache.temperatures.length)) {
          cache.labels.push(timeStr);
          cache.timestamps.push(timestamp);
        }
      } else if (type === 'pressure') {
        cache.pressures.push(value);
        // Only add label and timestamp if this is the first point or if both temp and pressure arrived
        if (cache.labels.length < cache.pressures.length || 
            (cache.temperatures.length === cache.pressures.length && 
             cache.labels.length < cache.pressures.length)) {
          cache.labels.push(timeStr);
          cache.timestamps.push(timestamp);
        }
      }
      
      // Keep only the latest maxPoints
      if (cache.labels.length > maxPoints) {
        cache.labels = cache.labels.slice(-maxPoints);
        cache.timestamps = cache.timestamps.slice(-maxPoints);
      }
      if (cache.temperatures.length > maxPoints) {
        cache.temperatures = cache.temperatures.slice(-maxPoints);
      }
      if (cache.pressures.length > maxPoints) {
        cache.pressures = cache.pressures.slice(-maxPoints);
      }
      
      updateCharts();
    }

    function updateCharts() {
      if (!currentSector) return;
      
      const cache = sectorCache[currentSector.id];
      
      // Update temperature chart
      temperatureChart.data.labels = cache.labels.slice(-maxPoints);
      temperatureChart.data.datasets[0].data = cache.temperatures.slice(-maxPoints);
      
      // Update pressure chart
      pressureChart.data.labels = cache.labels.slice(-maxPoints);
      pressureChart.data.datasets[0].data = cache.pressures.slice(-maxPoints);
      
      // Update predictions
      const tempPredictions = computePredictions(cache.temperatures, forecastDataWindow, forecastHorizon);
      const pressurePredictions = computePredictions(cache.pressures, forecastDataWindow, forecastHorizon);
      
      temperatureChart.data.datasets[1].data = tempPredictions;
      pressureChart.data.datasets[1].data = pressurePredictions;
      
      temperatureChart.update();
      pressureChart.update();
    }

    function updateValveStatus(isOpen) {
      valveOpen = isOpen;
      const indicator = document.getElementById('valveIndicator');
      const statusText = document.getElementById('valveStatusText');
      const toggleBtn = document.getElementById('valveToggleBtn');
      
      if (isOpen) {
        indicator.className = 'valve-indicator valve-open';
        statusText.textContent = 'Valve Open';
        toggleBtn.textContent = 'Close Valve';
        toggleBtn.className = 'valve-button close-valve';
      } else {
        indicator.className = 'valve-indicator valve-closed';
        statusText.textContent = 'Valve Closed';
        toggleBtn.textContent = 'Open Valve';
        toggleBtn.className = 'valve-button open-valve';
      }
    }

    /***********************
     * PREDICTION HELPER FUNCTIONS
     ***********************/
    function computePredictions(arr, N, K) {
      if (arr.length < 2) { const lastVal = Number(arr[arr.length - 1] || 0); return Array(K).fill(lastVal); }
      const data = arr.slice(-N).map(Number);
      const n = data.length;
      let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
      for (let i = 0; i < n; i++) { sumX += i; sumY += data[i]; sumXY += i * data[i]; sumXX += i * i; }
      const denominator = n * sumXX - sumX * sumX;
      const slope = denominator !== 0 ? (n * sumXY - sumX * sumY) / denominator : 0;
      const intercept = (sumY - slope * sumX) / n;
      const predictions = [];
      for (let i = n; i < n + K; i++) { predictions.push(Number((intercept + slope * i).toFixed(2))); }
      return predictions;
    }

    function computeWeeklyForecast(arr, N = 24, K = 7) {
      if (arr.length < 2) { const lastVal = Number(arr[arr.length - 1] || 0); return Array(K).fill(lastVal); }
      const data = arr.slice(-N).map(Number);
      const n = data.length;
      let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
      for (let i = 0; i < n; i++) { sumX += i; sumY += data[i]; sumXY += i * data[i]; sumXX += i * i; }
      const denominator = n * sumXX - sumX * sumX;
      const slope = denominator !== 0 ? (n * sumXY - sumX * sumY) / denominator : 0;
      const intercept = (sumY - slope * sumX) / n;
      const predictions = [];
      for (let i = n; i < n + K; i++) { predictions.push(Number((intercept + slope * i).toFixed(2))); }
      return predictions;
    }

    /***********************
     * THRESHOLD CHECKS AND ALERTS
     ***********************/
    function checkThresholds(type, value) {
      const numValue = Number(value);
      
      if (type === 'temperature') {
        if (numValue > thresholdTemp && !prevTempAbove) {
          tempWarningCount++;
          prevTempAbove = true;
          document.getElementById('tempWarningCount').textContent = tempWarningCount;
          document.getElementById('sidebarTempWarnings').textContent = tempWarningCount;
          addWarningLog('Temperature', value);
          
          if (tempWarningCount >= thresholdAlertCount && !tempAlertSent) {
            sendTelegramNotification('Temperature', value, new Date().toLocaleTimeString(), true);
            tempAlertSent = true;
          }
        } else if (numValue <= thresholdTemp) {
          prevTempAbove = false;
        }
      } else if (type === 'pressure') {
        if (numValue > thresholdPressure && !prevPressureAbove) {
          pressureWarningCount++;
          prevPressureAbove = true;
          document.getElementById('pressureWarningCount').textContent = pressureWarningCount;
          document.getElementById('sidebarPressureWarnings').textContent = pressureWarningCount;
          addWarningLog('Pressure', value);
          
          if (pressureWarningCount >= thresholdAlertCount && !pressureAlertSent) {
            sendTelegramNotification('Pressure', value, new Date().toLocaleTimeString(), true);
            pressureAlertSent = true;
          }
        } else if (numValue <= thresholdPressure) {
          prevPressureAbove = false;
        }
      }
    }

    /***********************
     * WARNING LOG FUNCTIONS
     ***********************/
    function addWarningLog(type, value) {
      const currentTime = new Date().toLocaleTimeString();
      const count = (type === 'Temperature') ? tempWarningCount : pressureWarningCount;
      const severity = classifySeverity(count);
      const logEntry = { id: Date.now() + Math.random(), time: currentTime, type, value, severity, acknowledged: false, telegramSent: false };
      
      warningLogs.unshift(logEntry);
      updateWarningLogTable();
      saveState();
      
      // Send to server
      fetch(`${apiBaseUrl}/warnings/${currentSector.id}/log`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        },
        body: JSON.stringify(logEntry)
      })
      .catch(error => {
        console.error('Error saving warning log:', error);
      });
    }

    function updateWarningLogTable() {
      const tbody = document.getElementById('warningLogBody');
      tbody.innerHTML = "";
      
      warningLogs.forEach(log => {
        const tr = document.createElement('tr');
        tr.setAttribute('data-id', log.id);
        
        if (log.acknowledged) tr.classList.add('acknowledged-row');
        if (log.severity === "Critical") tr.classList.add('critical-row');
        
        tr.innerHTML = `
          <td>${log.time}</td>
          <td>${log.type}</td>
          <td>${log.value}</td>
          <td>${log.severity}</td>
          <td>${log.acknowledged ? "Acknowledged" : "Active"}</td>
          <td>
            <button class="acknowledge-warning" data-id="${log.id}">Acknowledge</button>
            <button class="resend-telegram" data-id="${log.id}">Resend Telegram</button>
          </td>
        `;
        
        tbody.appendChild(tr);
      });
    }

    function classifySeverity(count) { 
      return (count >= 3) ? "Critical" : "Warning"; 
    }

    function sendTelegramNotification(type, value, time, isAlert = false) {
      // Update UI
      if (isAlert) {
        console.log(`ALERT: Telegram notification sent for ${type} at ${time} with value ${value}`);
        if (type === "Temperature") { 
          document.getElementById('tempNotificationStatus').textContent = "ALERT: Telegram sent at " + time; 
        } else if (type === "Pressure") { 
          document.getElementById('pressureNotificationStatus').textContent = "ALERT: Telegram sent at " + time; 
        }
      } else {
        console.log(`Telegram notification sent for ${type} at ${time} with value ${value}`);
        if (type === "Temperature") { 
          document.getElementById('tempNotificationStatus').textContent = "Telegram: Sent at " + time; 
        } else if (type === "Pressure") { 
          document.getElementById('pressureNotificationStatus').textContent = "Telegram: Sent at " + time; 
        }
      }
      
      // Send notification via REST API to Telegram Bot
      fetch(`${apiBaseUrl}/telegram/send`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        },
        body: JSON.stringify({
          type: type,
          value: value,
          sector: currentSector ? currentSector.name : 'Unknown',
          isAlert: isAlert
        })
      })
      .then(response => response.json())
      .then(data => {
        console.log('Telegram notification response:', data);
      })
      .catch(error => {
        console.error('Error sending Telegram notification:', error);
      });
      
      saveState();
    }

    /***********************
     * FILTERING & DOWNLOAD FUNCTIONS FOR HISTORICAL DATA
     ***********************/
    function getFilteredHistoricalData(filter) {
      const cache = sectorCache[currentSector.id];
      let indices = [];
      const now = Date.now();
      let threshold;
      
      switch(filter) {
        case 'hourly': threshold = 3600 * 1000; break;
        case 'daily': threshold = 24 * 3600 * 1000; break;
        case 'weekly': threshold = 7 * 24 * 3600 * 1000; break;
        case 'monthly': threshold = 30 * 24 * 3600 * 1000; break;
        default: threshold = 0;
      }
      
      if (threshold > 0) {
        for (let i = 0; i < cache.timestamps.length; i++) {
          if (now - cache.timestamps[i] <= threshold) {
            indices.push(i);
          }
        }
      } else {
        for (let i = 0; i < cache.timestamps.length; i++) { indices.push(i); }
      }
      
      return {
        labels: indices.map(i => cache.labels[i]),
        temperatures: indices.map(i => cache.temperatures[i]),
        pressures: indices.map(i => cache.pressures[i]),
        timestamps: indices.map(i => cache.timestamps[i])
      };
    }

    function updateHistoricalChart() {
      const filter = document.getElementById('filterSelect').value;
      const data = getFilteredHistoricalData(filter);
      
      historicalChart.data.labels = data.labels;
      historicalChart.data.datasets[0].data = data.temperatures;
      historicalChart.data.datasets[1].data = data.pressures;
      
      historicalChart.update();
    }

    /***********************
     * POST PROCESSING FUNCTIONS
     ***********************/
    function detectAnomalies(values) {
      if (values.length < 10) return [];
      
      const arr = values.slice(-10).map(Number);
      const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
      const std = Math.sqrt(arr.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / arr.length);
      
      const anomalies = [];
      arr.forEach((val, idx) => { 
        const z = Math.abs(val - mean) / std;
        if (z > 2) anomalies.push({ index: idx, value: val, z: z.toFixed(2) });
      });
      
      return anomalies;
    }

    function getRollingAverage(values) {
      if (values.length < 10) return null;
      
      const arr = values.slice(-10).map(Number);
      const avg = arr.reduce((a, b) => a + b, 0) / arr.length;
      
      return avg.toFixed(2);
    }

    function energyRecommendation(temp, pressure) {
      let rec = "";
      rec += (Number(temp) > thresholdTemp) ? "Temperature is high; consider reducing gas flow. " : "Temperature is optimal. ";
      rec += (Number(pressure) > thresholdPressure) ? "Pressure is high; check for pipeline integrity." : "Pressure is within safe limits.";
      
      return rec;
    }

    function calculateCorrelation(arrX, arrY) {
      const n = arrX.length;
      const meanX = arrX.reduce((a, b) => a + b, 0) / n;
      const meanY = arrY.reduce((a, b) => a + b, 0) / n;
      
      let numerator = 0, denomX = 0, denomY = 0;
      for (let i = 0; i < n; i++) {
        const dx = arrX[i] - meanX;
        const dy = arrY[i] - meanY;
        numerator += dx * dy;
        denomX += dx * dx;
        denomY += dy * dy;
      }
      
      return (numerator / Math.sqrt(denomX * denomY)).toFixed(2);
    }

    function updatePostProcessing() {
      const cache = sectorCache[currentSector.id];
      
      // Anomaly detection
      const tempAnomalies = detectAnomalies(cache.temperatures);
      const pressureAnomalies = detectAnomalies(cache.pressures);
      
      let anomalyHTML = "";
      if (tempAnomalies.length === 0 && pressureAnomalies.length === 0) {
        anomalyHTML = "<p>No anomalies detected in the last 10 readings.</p>";
      } else {
        if (tempAnomalies.length > 0) {
          anomalyHTML += "<p><strong>Temperature anomalies:</strong></p><ul>";
          tempAnomalies.forEach(a => { anomalyHTML += `<li>Value: ${a.value} °C (Z: ${a.z})</li>`; });
          anomalyHTML += "</ul>";
        }
        if (pressureAnomalies.length > 0) {
          anomalyHTML += "<p><strong>Pressure anomalies:</strong></p><ul>";
          pressureAnomalies.forEach(a => { anomalyHTML += `<li>Value: ${a.value} kPa (Z: ${a.z})</li>`; });
          anomalyHTML += "</ul>";
        }
      }
      document.getElementById('anomalyContent').innerHTML = anomalyHTML;
      
      // Trend analysis
      const tempAvg = getRollingAverage(cache.temperatures);
      const pressureAvg = getRollingAverage(cache.pressures);
      
      let trendHTML = `<p>Rolling Average Temperature (last 10 readings): ${tempAvg || "N/A"} °C</p>`;
      trendHTML += `<p>Rolling Average Pressure (last 10 readings): ${pressureAvg || "N/A"} kPa</p>`;
      
      document.getElementById('trendContent').innerHTML = trendHTML;
      
      // Severity classification
      const tempSeverity = classifySeverity(tempWarningCount);
      const pressureSeverity = classifySeverity(pressureWarningCount);
      
      let severityHTML = `<p>Temperature Severity: <strong>${tempSeverity}</strong></p>`;
      severityHTML += `<p>Pressure Severity: <strong>${pressureSeverity}</strong></p>`;
      
      document.getElementById('severityContent').innerHTML = severityHTML;
      
      // Energy efficiency recommendations
      const latestTemp = Number(cache.temperatures[cache.temperatures.length - 1] || 0);
      const latestPressure = Number(cache.pressures[cache.pressures.length - 1] || 0);
      
      const recommendation = energyRecommendation(latestTemp, latestPressure);
      document.getElementById('energyContent').innerHTML = `<p>${recommendation}</p>`;
      
      // Correlation analysis
      if (cache.temperatures.length >= 10 && cache.pressures.length >= 10) {
        const temps = cache.temperatures.slice(-10).map(Number);
        const pressures = cache.pressures.slice(-10).map(Number);
        const corr = calculateCorrelation(temps, pressures);
        
        document.getElementById('correlationContent').innerHTML = `<p>Pearson correlation coefficient: <strong>${corr}</strong></p>`;
      } else {
        document.getElementById('correlationContent').innerHTML = "<p>Not enough data to compute correlation.</p>";
      }
      
      // Energy efficiency score
      let efficiencyScore = 100;
      if (latestTemp > thresholdTemp) { efficiencyScore -= (latestTemp - thresholdTemp) * 5; }
      if (latestPressure > thresholdPressure) { efficiencyScore -= (latestPressure - thresholdPressure) * 3; }
      efficiencyScore = Math.max(0, Math.min(100, efficiencyScore));
      
      energyGaugeChart.data.datasets[0].data = [efficiencyScore, 100 - efficiencyScore];
      energyGaugeChart.options.plugins.title.text = `Score: ${efficiencyScore}`;
      energyGaugeChart.update();
    }

    /***********************
     * EVENT LISTENERS
     ***********************/
    // Valve toggle button
    document.getElementById('valveToggleBtn').addEventListener('click', function() {
      const newStatus = !valveOpen;
      updateValveStatus(newStatus);
      
      // Send valve control command via REST API to Control Center
      fetch(`${apiBaseUrl}/control/${currentSector.id}/valve`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        },
        body: JSON.stringify({
          status: newStatus ? 'open' : 'closed'
        })
      })
      .then(response => response.json())
      .then(data => {
        console.log('Valve control response:', data);
      })
      .catch(error => {
        console.error('Error controlling valve:', error);
        // Revert UI state if command failed
        updateValveStatus(!newStatus);
      });
    });

    // Sector selection handler
    document.getElementById('sectorsList').addEventListener('click', function(e) {
      if (e.target && e.target.nodeName === "LI") {
        Array.from(this.children).forEach(li => li.classList.remove('active'));
        e.target.classList.add('active');
        
        const selectedId = e.target.getAttribute('data-id');
        const selectedSector = sectors.find(sec => sec.id === selectedId);
        
        if (selectedSector) {
          currentSector = selectedSector;
          simulationTime = 0;
          
          // Update UI
          document.getElementById('sectorName').textContent = "Pipeline Sector: " + currentSector.name;
          document.getElementById('boltsCount').textContent = currentSector.bolts;
          document.getElementById('postProcessingSector').textContent = "Post Processing for: " + currentSector.name;
          
          // Fetch new sector data
          fetchSectorData(currentSector.id);
          
          // Reset warning counters
          tempWarningCount = 0; 
          pressureWarningCount = 0;
          document.getElementById('tempWarningCount').textContent = tempWarningCount;
          document.getElementById('pressureWarningCount').textContent = pressureWarningCount;
          document.getElementById('sidebarTempWarnings').textContent = tempWarningCount;
          document.getElementById('sidebarPressureWarnings').textContent = pressureWarningCount;
          
          // Update device list
          updateBoltsList();
          
          // Subscribe to new MQTT topics
          if (mqttClient && mqttClient.connected) {
            // Unsubscribe from old topics first
            sectors.forEach(sector => {
              if (sector.id !== currentSector.id) {
                mqttClient.unsubscribe(`sensors/${sector.id}/temperature`);
                mqttClient.unsubscribe(`sensors/${sector.id}/pressure`);
                mqttClient.unsubscribe(`actuators/${sector.id}/valve`);
              }
            });
            
            // Subscribe to new sector topics
            subscribeSectorTopics(currentSector.id);
          }
          
          saveState();
        }
      }
    });
    
    // Update sectors list
    function updateSectorsList() {
      const sectorsList = document.getElementById('sectorsList');
      sectorsList.innerHTML = "";
      
      sectors.forEach(sec => {
        const li = document.createElement('li');
        li.setAttribute('data-id', sec.id);
        li.innerHTML = sec.name + " (" + sec.bolts + " bolts)";
        
        if (currentSector && sec.id === currentSector.id) {
          li.classList.add('active');
        }
        
        // Edit button
        const editBtn = document.createElement('button');
        editBtn.textContent = "Edit";
        editBtn.classList.add('edit-sector');
        editBtn.style.marginLeft = "10px";
        editBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          
          let newBoltCount = prompt("Enter new number of bolts (max 4):", sec.bolts);
          newBoltCount = parseInt(newBoltCount);
          
          if (isNaN(newBoltCount) || newBoltCount < 1) { 
            alert("Please enter a valid number (1-4)"); 
            return; 
          }
          
          if (newBoltCount > 4) { 
            alert("Maximum bolts allowed is 4."); 
            newBoltCount = 4; 
          }
          
          // Update sector via API
          fetch(`${apiBaseUrl}/catalog/sectors/${sec.id}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
            },
            body: JSON.stringify({
              name: sec.name,
              bolts: newBoltCount
            })
          })
          .then(response => response.json())
          .then(data => {
            // Update local data
            sec.bolts = newBoltCount;
            sec.boltsHealth = Array(newBoltCount).fill(100);
            
            updateBoltsList();
            updateSectorsList();
            saveState();
          })
          .catch(error => {
            console.error('Error updating sector:', error);
            alert('Failed to update sector. Please try again.');
          });
        });
        
        // Delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = "Delete";
        deleteBtn.classList.add('delete-sector');
        deleteBtn.style.marginLeft = "5px";
        deleteBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          
          if (confirm("Are you sure you want to delete " + sec.name + "?")) {
            // Delete sector via API
            fetch(`${apiBaseUrl}/catalog/sectors/${sec.id}`, {
              method: 'DELETE',
              headers: {
                'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
              }
            })
            .then(response => {
              if (response.ok) {
                // Update local data
                sectors = sectors.filter(s => s.id !== sec.id);
                delete sectorCache[sec.id];
                
                if (currentSector && currentSector.id === sec.id) {
                  currentSector = sectors.length > 0 ? sectors[0] : null;
                  if (currentSector) {
                    fetchSectorData(currentSector.id);
                  }
                }
                
                updateSectorsList();
                updateBoltsList();
                saveState();
              } else {
                throw new Error('Failed to delete sector');
              }
            })
            .catch(error => {
              console.error('Error deleting sector:', error);
              alert('Failed to delete sector. Please try again.');
            });
          }
        });
        
        li.appendChild(editBtn);
        li.appendChild(deleteBtn);
        sectorsList.appendChild(li);
      });
      
      if (sectors.length === 0) {
        sectorsList.innerHTML = "<p>No sectors available. Please add a sector.</p>";
      }
    }
    
    // Update bolts list
    function updateBoltsList() {
      const boltsList = document.getElementById('boltsList');
      boltsList.innerHTML = "";
      
      if (!currentSector) return;
      
      for (let i = 1; i <= currentSector.bolts; i++) {
        const li = document.createElement('li');
        li.textContent = "Bolt " + i;
        
        // Fetch bolt status from API
        fetch(`${apiBaseUrl}/catalog/bolts/${currentSector.id}/${i}`, {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
          }
        })
        .then(response => response.json())
        .then(data => {
          if (data.health) {
            li.textContent += ` (Health: ${data.health}%)`;
            
            // Add visual indicator of health
            const healthIndicator = document.createElement('div');
            healthIndicator.style.width = '100%';
            healthIndicator.style.height = '4px';
            healthIndicator.style.marginTop = '5px';
            healthIndicator.style.background = '#444';
            
            const healthBar = document.createElement('div');
            healthBar.style.width = `${data.health}%`;
            healthBar.style.height = '100%';
            healthBar.style.background = data.health > 70 ? '#4CAF50' : data.health > 40 ? '#FFC107' : '#F44336';
            
            healthIndicator.appendChild(healthBar);
            li.appendChild(healthIndicator);
          }
        })
        .catch(error => {
          console.error('Error fetching bolt status:', error);
        });
        
        boltsList.appendChild(li);
      }
    }
    
    // Add sector button handler
    document.getElementById('addSectorBtn').addEventListener('click', function() {
      let sectorName = prompt("Enter sector name:", "New Sector");
      if (!sectorName) return;
      
      let count = prompt("How many bolts do you want to install? (Max = 4)");
      count = parseInt(count);
      
      if (isNaN(count) || count < 1) { 
        alert("Please enter a valid number (1-4)"); 
        return; 
      }
      
      if (count > 4) { 
        alert("Maximum bolts allowed is 4."); 
        count = 4; 
      }
      
      // Create sector via API
      fetch(`${apiBaseUrl}/catalog/sectors`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        },
        body: JSON.stringify({
          name: sectorName,
          bolts: count
        })
      })
      .then(response => response.json())
      .then(data => {
        const newSectorId = data.id || "sector" + (sectors.length + 1);
        const newSector = { id: newSectorId, name: sectorName, bolts: count, baseTemp: 25, basePressure: 100, boltsHealth: Array(count).fill(100), avgDegradationRate: 0 };
        
        sectors.push(newSector);
        sectorCache[newSectorId] = { labels: [], timestamps: [], temperatures: [], pressures: [] };
        
        updateSectorsList();
        saveState();
        
        // Subscribe to new sector's MQTT topics
        if (mqttClient && mqttClient.connected) {
          subscribeSectorTopics(newSectorId);
        }
      })
      .catch(error => {
        console.error('Error creating sector:', error);
        alert('Failed to create sector. Please try again.');
      });
    });
    
    // Forecasting settings handler
    document.getElementById('applyForecastSettings').addEventListener('click', function() {
      const newWindow = parseInt(document.getElementById('dataWindow').value);
      const newHorizon = parseInt(document.getElementById('forecastHorizon').value);
      
      if (isNaN(newWindow) || newWindow < 1) {
        alert("Please enter a valid data window value.");
        return;
      }
      
      if (isNaN(newHorizon) || newHorizon < 1) {
        alert("Please enter a valid forecast horizon value.");
        return;
      }
      
      forecastDataWindow = newWindow;
      forecastHorizon = newHorizon;
      
      // Update API settings
      fetch(`${apiBaseUrl}/analytics/settings`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        },
        body: JSON.stringify({
          dataWindow: forecastDataWindow,
          forecastHorizon: forecastHorizon
        })
      })
      .then(response => response.json())
      .then(data => {
        alert("Forecasting settings updated:\nData Window: " + forecastDataWindow + " readings\nForecast Horizon: " + forecastHorizon + " predictions");
      })
      .catch(error => {
        console.error('Error updating forecast settings:', error);
        alert('Failed to update settings. Please try again.');
      });
    });
    
    // Toggle warning details handler
    document.querySelectorAll('.toggle-details').forEach(button => {
      button.addEventListener('click', function(e) {
        e.stopPropagation();
        const details = this.parentElement.nextElementSibling;
        
        if (details.style.display === 'none' || details.style.display === '') { 
          details.style.display = 'block'; 
          this.textContent = 'Hide'; 
        } else { 
          details.style.display = 'none'; 
          this.textContent = 'Details'; 
        }
      });
    });
    
    // Warning acknowledge handlers
    document.querySelectorAll('.acknowledge-warning[data-type]').forEach(button => {
      button.addEventListener('click', function(e) { 
        e.stopPropagation(); 
        const type = this.getAttribute('data-type'); 
        
        // Send acknowledgement to server
        fetch(`${apiBaseUrl}/warnings/${currentSector.id}/acknowledge`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
          },
          body: JSON.stringify({
            type: type
          })
        })
        .then(response => response.json())
        .then(data => {
          alert(`${type} warning acknowledged.`);
        })
        .catch(error => {
          console.error('Error acknowledging warning:', error);
          alert('Failed to acknowledge warning. Please try again.');
        });
      });
    });
    
    // Resend telegram handlers
    document.querySelectorAll('.resend-telegram').forEach(button => {
      button.addEventListener('click', function(e) { 
        e.stopPropagation(); 
        const type = this.getAttribute('data-type'); 
        
        sendTelegramNotification(
          type, 
          (type === "Temperature" ? document.getElementById('temperatureValue').textContent : document.getElementById('pressureValue').textContent),
          new Date().toLocaleTimeString()
        );
      });
    });
    
    // Warning log table event handlers
    document.getElementById('warningLogBody').addEventListener('click', function(e) {
      const target = e.target;
      const logId = target.getAttribute('data-id');
      
      if (target.classList.contains('acknowledge-warning')) {
        // Update local data
        warningLogs = warningLogs.map(log => { 
          if (log.id == logId) log.acknowledged = true; 
          return log; 
        });
        
        updateWarningLogTable();
        saveState();
        
        // Update server
        fetch(`${apiBaseUrl}/warnings/${currentSector.id}/acknowledge/${logId}`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
          }
        })
        .catch(error => {
          console.error('Error acknowledging warning:', error);
        });
      } else if (target.classList.contains('resend-telegram')) {
        const logEntry = warningLogs.find(log => log.id == logId);
        
        if (logEntry) {
          sendTelegramNotification(logEntry.type, logEntry.value, new Date().toLocaleTimeString());
          logEntry.telegramSent = true;
          updateWarningLogTable();
          saveState();
        }
      }
    });
    
    // Sidebar navigation handler
    const sidebarNavItems = document.querySelectorAll('.nav-menu li');
    sidebarNavItems.forEach(item => {
      item.addEventListener('click', function() {
        // Update active tab
        sidebarNavItems.forEach(el => el.classList.remove('active'));
        this.classList.add('active');
        
        // Show correct sidebar tab
        const tab = this.getAttribute('data-tab');
        document.getElementById('sectorsTab').style.display = 'none';
        document.getElementById('devicesTab').style.display = 'none';
        document.getElementById('postProcessingTab').style.display = 'none';
        document.getElementById('warningsTab').style.display = 'none';
        document.getElementById('historicalDataTab').style.display = 'none';
        document.getElementById(tab + 'Tab').style.display = 'block';
        
        // Show correct main content view
        document.getElementById('dashboardView').style.display = 'none';
        document.getElementById('warningsView').style.display = 'none';
        document.getElementById('postProcessingView').style.display = 'none';
        document.getElementById('historicalDataView').style.display = 'none';
        
        if (tab === "warnings") { 
          document.getElementById('warningsView').style.display = 'block'; 
        } else if (tab === "postProcessing") { 
          document.getElementById('postProcessingView').style.display = 'block'; 
          updatePostProcessing();
        } else if (tab === "historicalData") {
          document.getElementById('historicalDataView').style.display = 'block';
          updateHistoricalChart();
        } else { 
          document.getElementById('dashboardView').style.display = 'block'; 
        }
      });
    });
    
    // Historical data download handler
    document.getElementById('downloadDataBtn').addEventListener('click', function() {
      const filter = document.getElementById('filterSelect').value;
      const data = getFilteredHistoricalData(filter);
      
      let csvContent = "data:text/csv;charset=utf-8,Timestamp,Time,Temperature,Pressure\n";
      
      for (let i = 0; i < data.timestamps.length; i++) {
        const ts = data.timestamps[i];
        const timeString = data.labels[i];
        const temp = data.temperatures[i];
        const pressure = data.pressures[i];
        const dateStr = new Date(ts).toLocaleString();
        
        csvContent += `${dateStr},${timeString},${temp},${pressure}\n`;
      }
      
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", `${currentSector.name.replace(/\s+/g, '_')}_historical_data.csv`);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });
    
    // Historical data filter change handler
    document.getElementById('filterSelect').addEventListener('change', updateHistoricalChart);
    
    /***********************
     * PERIODIC UPDATES AND INITIALIZATION
     ***********************/
    // Update charts every few seconds
    function startPeriodicUpdates() {
      // Update post processing analytics every 5 seconds
      setInterval(updatePostProcessing, 5000);
      
      // Update weekly forecast every 15 seconds
      setInterval(updateWeeklyForecast, 15000);
      
      // Update historical chart every 30 seconds
      setInterval(updateHistoricalChart, 30000);
      
      // Save state every minute
      setInterval(saveState, 60000);
    }
    
    // Update weekly forecast chart
    function updateWeeklyForecast() {
      const cache = sectorCache[currentSector.id];
      let tempForecast = [], pressureForecast = [];
      
      // Get weekly forecast data from Analytics Microservice
      fetch(`${apiBaseUrl}/analytics/${currentSector.id}/weekly-forecast`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        }
      })
      .then(response => response.json())
      .then(data => {
        if (data.temperature && data.pressure) {
          weeklyForecastChart.data.datasets[0].data = data.temperature;
          weeklyForecastChart.data.datasets[1].data = data.pressure;
          weeklyForecastChart.update();
        } else {
          // Fallback to local calculation
          if (cache.temperatures.length >= 24 && cache.pressures.length >= 24) {
            tempForecast = computeWeeklyForecast(cache.temperatures, 24, 7);
            pressureForecast = computeWeeklyForecast(cache.pressures, 24, 7);
          } else {
            const currentTemp = Number(cache.temperatures[cache.temperatures.length - 1] || 0);
            const currentPressure = Number(cache.pressures[cache.pressures.length - 1] || 0);
            tempForecast = Array(7).fill(currentTemp);
            pressureForecast = Array(7).fill(currentPressure);
          }
          
          weeklyForecastChart.data.datasets[0].data = tempForecast;
          weeklyForecastChart.data.datasets[1].data = pressureForecast;
          weeklyForecastChart.update();
        }
      })
      .catch(error => {
        console.error('Error fetching weekly forecast:', error);
        
        // Fallback to local calculation
        if (cache.temperatures.length >= 24 && cache.pressures.length >= 24) {
          tempForecast = computeWeeklyForecast(cache.temperatures, 24, 7);
          pressureForecast = computeWeeklyForecast(cache.pressures, 24, 7);
        } else {
          const currentTemp = Number(cache.temperatures[cache.temperatures.length - 1] || 0);
          const currentPressure = Number(cache.pressures[cache.pressures.length - 1] || 0);
          tempForecast = Array(7).fill(currentTemp);
          pressureForecast = Array(7).fill(currentPressure);
        }
        
        weeklyForecastChart.data.datasets[0].data = tempForecast;
        weeklyForecastChart.data.datasets[1].data = pressureForecast;
        weeklyForecastChart.update();
      });
    }
    
    /***********************
     * INITIALIZATION
     ***********************/
    // Check authentication state on page load
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize animation
      initParticles();
      animateParticles();
      
      // Check if user is logged in
      checkAuthState();
    });
    
    // Initialize dashboard after successful login
    function initDashboard() {
      // Load saved state
      loadState();
      
      // Initialize UI components
      updateSectorsList();
      updateBoltsList();
      updateWarningLogTable();
      
      // If we have a current sector
      if (currentSector) {
        document.getElementById('sectorName').textContent = "Pipeline Sector: " + currentSector.name;
        document.getElementById('boltsCount').textContent = currentSector.bolts;
        document.getElementById('postProcessingSector').textContent = "Post Processing for: " + currentSector.name;
        
        // Fetch sector data
        fetchSectorData(currentSector.id);
      }
      
      // Start periodic updates
      startPeriodicUpdates();
    }
  </script>
</body>
// this part of the code is the one that is responsible for the login bypass

</body> 

<script>
  // Override the login form to bypass authentication for testing
  document.getElementById('loginForm').addEventListener('submit', function(e) {
    e.preventDefault();
    
    // Get entered username for display
    const username = document.getElementById('username').value || 'Admin';
    
    // Set a fake auth token
    localStorage.setItem('auth_token', 'test_token_12345');
    
    // Set current user
    isAuthenticated = true;
    currentUser = { name: username, role: 'administrator' };
    
    // Show dashboard
    document.getElementById('loginContainer').style.display = 'none';
    document.getElementById('mainDashboard').style.display = 'block';
    
    // Update user profile with first letter of username
    const userInitial = username.charAt(0).toUpperCase();
    document.querySelectorAll('.user-profile').forEach(el => {
      el.textContent = userInitial;
    });
    
    // Initialize dashboard
    try {
      // Initialize UI components
      updateSectorsList();
      updateBoltsList();
      updateWarningLogTable();
      
      // Initialize charts
      initializeAllCharts();
      
      // Update UI with demo data
      document.getElementById('temperatureValue').textContent = '25.3';
      document.getElementById('pressureValue').textContent = '102.5';
      
      // If we have a current sector
      if (currentSector) {
        document.getElementById('sectorName').textContent = "Pipeline Sector: " + currentSector.name;
        document.getElementById('boltsCount').textContent = currentSector.bolts;
        document.getElementById('postProcessingSector').textContent = "Post Processing for: " + currentSector.name;
      }
      
      // Generate mock data for charts
      generateMockData();
      
      console.log('Dashboard initialized successfully');
    } catch (error) {
      console.error('Error initializing dashboard:', error);
    }
  });
  
  // Cancel API check on page load
  window.addEventListener('DOMContentLoaded', function() {
    // Don't check authentication with the server
    // Instead, just show login form
    document.getElementById('loginContainer').style.display = 'flex';
    document.getElementById('mainDashboard').style.display = 'none';
  });
  
  // Generate mock data for testing
  function generateMockData() {
    // Mock temperature and pressure data
    const mockTemp = [];
    const mockPressure = [];
    const mockLabels = [];
    const mockTimestamps = [];
    
    const now = new Date();
    
    for (let i = 0; i < 20; i++) {
      // Generate time points going back in time
      const time = new Date(now - (19-i) * 60000);
      mockLabels.push(time.toLocaleTimeString());
      mockTimestamps.push(time.getTime());
      
      // Generate random but somewhat realistic data
      const baseTemp = 25;
      const basePressure = 100;
      mockTemp.push((baseTemp + Math.sin(i/3)*2 + (Math.random()-0.5)).toFixed(1));
      mockPressure.push((basePressure + Math.cos(i/4)*3 + (Math.random()-0.5)).toFixed(1));
    }
    
    // Update cache
    if (currentSector && sectorCache[currentSector.id]) {
      sectorCache[currentSector.id].labels = mockLabels;
      sectorCache[currentSector.id].timestamps = mockTimestamps;
      sectorCache[currentSector.id].temperatures = mockTemp;
      sectorCache[currentSector.id].pressures = mockPressure;
      
      // Update charts
      temperatureChart.data.labels = mockLabels;
      temperatureChart.data.datasets[0].data = mockTemp;
      const tempPredictions = computePredictions(mockTemp, forecastDataWindow, forecastHorizon);
      temperatureChart.data.datasets[1].data = tempPredictions;
      temperatureChart.update();
      
      pressureChart.data.labels = mockLabels;
      pressureChart.data.datasets[0].data = mockPressure;
      const pressurePredictions = computePredictions(mockPressure, forecastDataWindow, forecastHorizon);
      pressureChart.data.datasets[1].data = pressurePredictions;
      pressureChart.update();
      
      // Update weekly forecast
      const tempForecast = Array(7).fill(0).map((_, i) => 
        (baseTemp + 2 + Math.sin(i/2)*3 + (Math.random()-0.5)).toFixed(1));
      const pressureForecast = Array(7).fill(0).map((_, i) => 
        (basePressure + Math.cos(i/3)*4 + (Math.random()-0.5)*2).toFixed(1));
      
      if (weeklyForecastChart) {
        weeklyForecastChart.data.datasets[0].data = tempForecast;
        weeklyForecastChart.data.datasets[1].data = pressureForecast;
        weeklyForecastChart.update();
      }
      
      // Update historical chart
      if (historicalChart) {
        historicalChart.data.labels = mockLabels;
        historicalChart.data.datasets[0].data = mockTemp;
        historicalChart.data.datasets[1].data = mockPressure;
        historicalChart.update();
      }
    }
  }
</script>
</html>